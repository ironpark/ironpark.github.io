{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"53625532a96c53b56eb2fd6f7cbb09fea66e4f828365acac42599c3916f7b270","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"ブログ自動公開（feat. Obsidian）","subTitle":"誰でもそれらしい計画は持っている","description":"Obsidianで文章を書いて保存するだけで自動的にウェブサイトに公開される完全自動化システム。GitHub ActionsとGit同期を活用した、執筆に専念できる環境構築","series":"똑똑한 블로그 만들기","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"ja","thumbnail":null,"originalLang":"ko"},"content":"## 記事を一つ公開するのがなぜこんなに複雑なのか？\n\n[前回の投稿](https://ironpark.github.io/posts/my-ideal-dev-blog/)ではブログを作る理由と技術選択の経緯について話した。今回は、そうして作ったブログで記事を一つ公開するまでになぜこんなに複雑なのか、そしてその過程をどう解決しようとしたのかを話そうと思う。\n\nGitHub Pagesベースの静的ブログを運営して感じた最大の不便さは、**公開プロセスそのもの**だ。\n\n別途データベースやサーバー環境がないため管理ページや専用エディターもない。その結果、下書き作成 → 保存 → 修正 → 公開という基本的な執筆フローがスムーズでない。さらに記事とフロントエンドコードが一つのリポジトリに混在している環境は、少しでも気を抜くと迷走してしまう自分にとってはほぼ災害に近い。だからこそ**関心の分離**が切実だった。\n\n### 誰でもそれっぽい計画はある\n![[get-punched-in-the-face.jpg]]\n\n**私の計画はこうだった：**\n1. Obsidianで記事を書く\n2. Gitプラグインが個人リポジトリに自動で同期する\n3. GitHub Actionsがブログリポジトリに記事を自動デプロイする\n\nこうすればスマホ、タブレット、デスクトップどこからでも記事を書いてすぐに公開できる完璧なシステムになると確信していた。Obsidianで執筆にだけ集中し、GitHub Actionsの自動化マジックであとは勝手に処理される…そんな美しい計画だったのだが…\n\n頭の中では完璧に回っていた計画だったが、実際には思ったより多くの落とし穴が潜んでいた。\n\n> 誰でもそれっぽい計画はある  ~~殴られるまでは~~\n\n## ソリューション探索\n\n### 第一の計画\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant 개발자 as 👨‍💻 執筆者\nparticipant 옵시디언 as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vaultリポジトリ\nparticipant BlogRepo as 📁 Blogリポジトリ\nparticipant Pages as 🌐 GitHub Pages\n개발자 ->> 옵시디언: ブログ記事作成\n옵시디언 ->> VaultRepo: 同期コミット\nNote over VaultRepo: ブログ記事フィルタリングコミットアクション実行\nVaultRepo ->> BlogRepo: ブログ記事コミット\nNote over BlogRepo: ビルド＆デプロイ\nBlogRepo ->> Pages: 静的サイトデプロイ\nNote over 개발자: ローカルでCSS修正、コミット\n개발자 ->> BlogRepo: 💥 コミットプッシュ試行 (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> 개발자: ❌ REJECTED! remote changes exist <br/> コミット前にpull必要 → コンフリクトの可能性（自動コミットと手動修正が混在）\nend\n```\n\n最も懸念していたのは**自動コミットと手動コミットが一つのリポジトリ内で絡み合う状況**だった。  \nGitHub Actionsが記事を自動でコミットしてデプロイしている間に、自分がローカルでCSSやレイアウトを修正したらどうなるか？\n\nおそらくプッシュを試みる瞬間、リモートリポジトリにはすでに自動化が生成したコミットが先に入っているだろう。その場合 `git push` は拒否され、コンフリクトを解決するために再度 `git reset HEAD^ & git pull` をしなければならない面倒な状況が起こる可能性が高い。\n\nつまり、記事を公開しようと作った自動化が、うっかりすると**フルタイムのコンフリクト担当職に**自分を転職させるかもしれないという話だ。\n\n### 第二の計画\n根本的な問題の原因は自動化プロセスがブログ記事を直接メインブランチにコミットしていることだ。\n\nでは、**ビルド時に記事を動的に取得すればどうか？**\n```mermaid\nsequenceDiagram\nautonumber\nparticipant 개발자 as 👨‍💻 執筆者\nparticipant 옵시디언 as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vaultリポジトリ\nparticipant BlogRepo as 📁 Blogリポジトリ\nparticipant Pages as 🌐 GitHub Pages\n\n개발자 ->> 옵시디언: ブログ記事作成\n옵시디언 ->> VaultRepo: 同期コミット\nNote over VaultRepo: 記事保存\n\n개발자 ->> BlogRepo: CSS/レイアウト修正\nBlogRepo ->> BlogRepo: ビルドトリガー\n\nrect rgb(200,250,200)\nNote over BlogRepo: ビルドプロセス開始\nBlogRepo ->> VaultRepo: 記事データfetch (checkout)\nVaultRepo -->> BlogRepo: マークダウンファイル群\nNote over BlogRepo: 前処理＆サイトビルド\nend\n\nBlogRepo ->> Pages: 静的サイトデプロイ\n```\n\n\nこうすれば**記事リポジトリとブログコードリポジトリが完全に分離**される。各々の領域で独立してコミットし、ビルド時にだけ出会う形だ。コンフリクト？そんなものはそもそも発生し得ない構造だ。\n\nしかしこの構造には致命的な問題があった。**公開リポジトリが非公開リポジトリのデータを取得しなければならない点**だ。これは一般的なセキュリティ原則に反する逆アクセスだった。\n\n私のObsidian Vaultは単なるブログリポジトリではない。個人の日記、業務メモ、プロジェクトアイデア、時には機密情報まで含む自分だけのデジタル脳だ。そんな個人リポジトリに公開ブログがアクセスするということ自体が不安だった。\n\nPersonal Access Tokenを使って非公開リポジトリをクローンする方法も検討したが、リスクが多すぎた：\n\n- 公開リポジトリのActionsログに機密情報が露出する可能性\n- トークンが盗まれた場合Vault全体が危険にさらされるセキュリティ問題\n- 誤って非公開ファイルがビルド過程に含まれるリスク\n\n何よりも自分を信用できないためこの計画は破棄される。\n\n### 最後？\n\n![[gendo-Ikari.jpg]]\n> 記事公開システム ~~人類~~ 補完計画最終版\n\nそこで発想を転換した。**最初の計画通りブログリポジトリに自動でコミットするが、別のブランチを使えばどうか？**\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidianノート\"]\n B[\"GitHub Actions\"]\n C[\"前処理＆翻訳\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-syncブランチ\"]\n E[\"masterブランチ\"]\n F[\"Github Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"ブログデザイン修正\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"Github Page\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nこの構造では：\n- VaultのGitHub Actionsが記事を処理しブログリポジトリの `auto-sync` ブランチにプッシュ\n- ブログのビルドプロセスが `master` と `auto-sync` の両方のブランチをチェックアウトしてマージ後ビルド\n- デザインやコード修正は通常通り `master` ブランチに直接コミット\n\nコンフリクトの余地を根本的に断ちつつ、セキュリティ問題なく二つのリポジトリを連携できる構造だ。\n\n### 直面した課題たち\n1. Obsidian文法\nObsidianは独自のマークダウン拡張文法を使う。`![[image.png]]` のような画像埋め込みや `[[別のノート]]` のようなウィキリンクは基本的にマークダウンの前処理器でそのままレンダリングされない。これを変換する前処理工程が必須だった。\n\n2. 画像パスとアセット管理\nObsidian Vaultの画像は通常ノートと同じフォルダに保存されるが、ウェブでは `/assets/images/` のような統一パスを使うのが一般的だ。ビルド時に画像を正しい場所にコピーしパスを修正する必要があった。\n\n3. 多言語対応とAI翻訳\nブログを韓国語、英語、日本語で提供したかった。毎回3言語で書くのは無理だし自分の外国語能力も乏しいためAI翻訳を導入した。しかし技術用語やコードブロックは翻訳されてはいけないなど細やかな処理が必要だった。\n\n\n---\n\n> 💡 **この自動化システムに興味があるなら**\n> \n> 全コードは[GitHubリポジトリ](https://github.com/ironpark/ironpark.github.io)で確認できる。  \n> 特に `.github/workflows/` フォルダのアクションファイルを見ると詳細な実装がわかる。  \n>\n> 似たシステムを構築したいならいつでも質問を残してほしい。一緒により良い執筆環境を作っていこう。"}