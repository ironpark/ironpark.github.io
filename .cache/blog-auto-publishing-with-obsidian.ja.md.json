{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"940f9825842a66a2e6f80e144ed574ed5f0410895a0b55d127219638cc414e92","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"ブログ自動公開（feat. Obsidian）","subTitle":"誰でもそれらしい計画は持っている","description":"Obsidianで文章を書いて保存するだけで自動的にウェブサイトに公開される完全自動化システム。GitHub ActionsとGit同期を活用した、執筆に専念できる環境構築","series":"똑똑한 블로그 만들기","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"ja","thumbnail":null,"originalLang":"ko"},"content":"## 記事ひとつ投稿するのがなぜこんなに複雑なのか？\n\n[[나만의 블로그를 만들다|前回の投稿]] ではブログを作った理由と技術選択の経緯について話した。今回は、そうして作ったブログで記事ひとつを投稿するまでになぜこんなに複雑なのか、そしてその過程をどう解決しようとしたのかを話してみようと思う。\n\nGitHub Pages ベースの静的ブログを運営して感じた最大の不便さは **投稿プロセスそのもの**だ。\n\n別途のデータベースやサーバー環境がないので管理ページや専用エディターもない。その結果、下書き作成 → 保存 → 修正 → 投稿という基本的な執筆フローがスムーズでない。さらに記事とフロントエンドコードがひとつのリポジトリに混ざっている環境は、少しでも気を抜くと迷走してしまう自分にとってはほぼ災害に近い。だからこそ **関心の分離** が切実だった。\n\n### 誰でもそれっぽい計画はある\n![[get-punched-in-the-face.jpg]]\n\n**最初の計画はこうだった：**\n1. Obsidianで記事を書く\n2. Gitプラグインが個人リポジトリに自動で同期する\n3. GitHub Actionsがブログリポジトリに記事を自動デプロイする\n\nこうすればスマホ、タブレット、デスクトップどこからでも書いてすぐに配信できる完璧なシステムになると確信していた。Obsidianで執筆に集中し、GitHub Actionsの自動化マジックで残りは勝手に処理される…そんな美しい計画だったのだが…\n\n頭の中では完璧に回っていた計画だったが、実際には思ったより多くの落とし穴が潜んでいた。\n\n> 誰でもそれっぽい計画はある  ~~殴られるまでは~~\n\n## ソリューション探索\n\n### 第一案\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant 개발자 as 👨‍💻 執筆者\nparticipant 옵시디언 as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault リポジトリ\nparticipant BlogRepo as 📁 Blog リポジトリ\nparticipant Pages as 🌐 GitHub Pages\n개발자 ->> 옵시디언: ブログ記事作成\n옵시디언 ->> VaultRepo: 同期コミット\nNote over VaultRepo: ブログ記事フィルタリングコミットアクション実行\nVaultRepo ->> BlogRepo: ブログ記事コミット\nNote over BlogRepo: ビルド＆デプロイ\nBlogRepo ->> Pages: 静的サイトデプロイ\nNote over 개발자: ローカルでCSS修正、コミット\n개발자 ->> BlogRepo: 💥 コミットプッシュ試行 (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> 개발자: ❌ REJECTED! remote changes exist <br/> コミット前にpullが必要 → コンフリクトの可能性（自動コミットと手動修正が混在）\nend\n```\n\n最も懸念していたのは **自動コミットと手動コミットがひとつのリポジトリ内で絡み合う状況**だった。  \nGitHub Actionsが記事を自動でコミットしてデプロイしている間に、自分がローカルでCSSやレイアウトを修正したらどうなるだろう？\n\nおそらくプッシュを試みる瞬間、リモートリポジトリにはすでに自動化が生成したコミットが先に入っているはずだ。その場合 `git push` は拒否され、コンフリクトを解決するために再度 `git reset HEAD^ & git pull` をしなければならない面倒な状況が起こる可能性が高い。\n\n記事投稿のために作った自動化のせいで **フルタイムのコンフリクト管理者** になりかけた。\n\n### 第二案\n根本的な問題の原因は自動化プロセスがブログ記事を直接メインブランチにコミットしていることだ。\n\nでは、**ビルド時に記事を動的に取り込むのはどうか？**\n```mermaid\nsequenceDiagram\nautonumber\nparticipant 개발자 as 👨‍💻 執筆者\nparticipant 옵시디언 as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault リポジトリ\nparticipant BlogRepo as 📁 Blog リポジトリ\nparticipant Pages as 🌐 GitHub Pages\n\n개발자 ->> 옵시디언: ブログ記事作成\n옵시디언 ->> VaultRepo: 同期コミット\nNote over VaultRepo: 記事保存\n\n개발자 ->> BlogRepo: CSS/レイアウト修正\nBlogRepo ->> BlogRepo: ビルドトリガー\n\nrect rgb(200,250,200)\nNote over BlogRepo: ビルドプロセス開始\nBlogRepo ->> VaultRepo: 記事データfetch (checkout)\nVaultRepo -->> BlogRepo: マークダウンファイル群\nNote over BlogRepo: 前処理＆サイトビルド\nend\n\nBlogRepo ->> Pages: 静的サイトデプロイ\n```\n\n\nこうすれば **記事リポジトリとブログコードリポジトリが完全に分離**される。各々の領域で独立してコミットし、ビルド時だけが接点となる。コンフリクト？そんなものはそもそも起こりえない構造だ。\n\nしかしこの構造には致命的な問題があった。**公開リポジトリが非公開リポジトリのデータを取得しなければならない点**だ。これは一般的なセキュリティ原則に反する逆方向アクセスだった。\n\n私のObsidian Vaultは単なるブログリポジトリではない。個人の日記、業務メモ、プロジェクトアイデア、時には機微な情報まで含む自分だけのデジタル脳だ。そんな個人リポジトリに公開ブログがアクセスすること自体が不安だった。\n\n- 公開リポジトリのActionsログに機微情報が露出する可能性\n- トークンが盗まれた場合Vault全体が危険に晒されるセキュリティ問題\n- 誤って非公開ファイルがビルド過程に含まれるリスク\n\n何よりも自分を信用できなかったためこの計画は破棄された。\n\n### 最後の案？\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> 記事投稿システム ~~人類~~ 補完計画最終版\n\nそこで発想を転換した。**最初の計画通りブログリポジトリに自動でコミットするが、別のブランチを使ったらどうか？**\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidianノート\"]\n B[\"GitHub Actions\"]\n C[\"前処理＆翻訳\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync ブランチ\"]\n E[\"master ブランチ\"]\n F[\"Github Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"ブログデザイン修正\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"Github Page\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nこの構造では：\n- VaultのGitHub Actionsが記事を処理しブログリポジトリの `auto-sync` ブランチにプッシュした後\n- ブログのビルドプロセスが `master` と `auto-sync` の両方をチェックアウトしてマージしてビルド\n- デザインやコード修正は通常通り `master` ブランチに直接コミット\n\nコンフリクトの余地を根本的に断ちつつ、セキュリティ問題なく二つのリポジトリを連携できる構造だ。\n\n\n## この投稿で扱わなかったこと\n\nObsidianで書いた記事は基本的にマークダウン形式に従うが、そのままブログに適用するのは難しかった。そこで別途前処理器を作る必要があり、その過程で直面した様々な問題があった。今回は触れなかったが、機会があれば別途まとめて公開する予定だ。\n\n1. **Obsidian文法**  \n    Obsidianは独自のマークダウン拡張文法を使う。例えば `![[image.png]]` 形式の画像埋め込みや `[[別のノート]]` のようなウィキリンクは基本マークダウンレンダラーではそのまま表示されない。したがってこれを変換する前処理が必須だった。\n    \n2. **画像パスとアセット管理**  \n    Obsidian Vaultの画像ファイルは通常ノートと同じフォルダに保存されるが、ウェブでは一般的に `/assets/images/` のような統一パスを使う。ビルド時に画像を正しい場所にコピーし、パスを修正する作業が必要だった。\n    \n3. **Mermaid Diagram対応**  \n    この投稿ではmermaid.jsを使って図を作成した。しかし静的サイトビルド過程でこれをそのまま表現するには、動的レンダリングをサポートする別の処理方法が必要だった。\n    \n4. **多言語対応とAI翻訳**  \n    ブログを韓国語、英語、日本語で提供したかった。しかし毎回三言語で直接書くのは難しく、自分の外国語能力にも限界があったためAI翻訳を導入した。ただし翻訳過程でマークダウン文法が変形したり壊れたりと様々な問題があり、プロンプトを何度か修正することになった。\n\n## 実装\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # 不要なworkflow再実行を防ぐため特定ファイル変更時のみ実行\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Get current date\n        id: date\n        run: echo \"::set-output name=date::$(date +'%Y-%m-%d')\"\n      # ブレインリポジトリ（現在のリポジトリ）をチェックアウト\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      \n      # ironpark.github.io の auto-sync ブランチをチェックアウト\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n\n      # pnpmのインストール＆ironpark.github.ioのauto-syncブランチのキャッシュ設定\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n\n      - name: Sync Contents\n        run: |\n          # 古いコンテンツ（posts, assets, output）をクリーンアップ\n          rm -rf /contents/{posts,assets,output}\n          \n          # ディレクトリ作成とファイルコピー\n          mkdir -p /contents/{posts,assets}\n          cp -r /brain/2.Areas/Blog/*.md /contents/posts/ 2>/dev/null || echo \"No markdown files found\"\n          cp -r /brain/Z.Assets/* /contents/assets/* 2>/dev/null || echo \"No image assets found\"\n      \n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # コンテンツの変更をチェックし、あればプッシュ\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n            echo \"No changes detected\"\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n            echo \"Changes detected\"\n          fi\n      # 変更があればコンテンツをプッシュ\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from ${{ steps.date.outputs.date }}\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n## 今後の計画\n\n現在は `published` メタデータで公開状態を管理しているが、今後は予約投稿システムを作り「決まった日に静かに記事が上がる」方式を試してみる予定だ。\n\nそれ以外にも一定時間経過後にVelogやMediumなど他プラットフォームへ自動クロスポストしたり、投稿と同時にTwitter(X)、LinkedInなどSNSに要約とリンクを流す機能も考えているが、いつ実装できるかは未定…\n\n> まだアイデア段階だが、GitHub Actionsを無料枠の限界まで使い倒すのが目標だ。（ここまでくると機械ではなく自分が酷使されている気分ではあるが…）\n\n\n---\n\n> 💡 **この自動化システムに興味があるなら**\n> \n> 全コードは [GitHubリポジトリ](https://github.com/ironpark/ironpark.github.io) で確認できる。  \n> 特に `.github/workflows/` フォルダのアクションファイルを見ると詳細な実装内容がわかる。  \n>\n> 似たシステムを構築したい場合はいつでも質問を残してほしい。一緒により良い執筆環境を作っていこう。"}