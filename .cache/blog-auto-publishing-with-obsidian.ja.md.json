{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"daddefcaafab78bcdaad3b49dc2d38fa6587f1e778cf0d8b7a8383bfb8eb40eb","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"ブログ自動公開（feat. Obsidian）","subTitle":"誰もがそれらしい計画を持っている","description":"Obsidianで文章を書いて保存するだけで、自動的にウェブサイトに公開される完全自動化システム。GitHub ActionsとGitの同期によって実現する、執筆に専念できる環境構築","series":"똑똑한 블로그 만들기","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"ja","thumbnail":null,"originalLang":"ko"},"content":"## 記事を一つ公開するのがなぜこんなに複雑なのか？\n\n[[나만의 블로그를 만들다|前回の投稿]] では、ブログを作った理由と技術選択の経緯について話した。今回は、そうして作ったブログで記事を一つ公開するまでになぜこんなに複雑なのか、そしてその過程をどう解決しようとしたのかを話そうと思う。\n\nGitHub Pages ベースの静的ブログを運営して感じた最大の不便さは、**公開プロセスそのもの**だ。\n\n別途のデータベースやサーバー環境がないので管理ページや専用エディターもない。その結果、下書き作成 → 保存 → 修正 → 公開という基本的な文章作成の流れがスムーズでない。さらに記事とフロントエンドコードが一つのリポジトリに混ざっている環境は、少しでも気を抜くと迷走しがちな自分にとってはほぼ災害に近い。だからこそ、**関心の分離**が切実だった。\n\n### 誰でもそれっぽい計画はある\n![[get-punched-in-the-face.jpg]]\n\n**最初の計画はこうだった：**\n1. Obsidianで記事を書く\n2. Gitプラグインが個人リポジトリに自動で同期する\n3. GitHub Actionsがブログリポジトリに記事を自動デプロイする\n\nこうすればスマホ、タブレット、デスクトップどこからでも記事を書いてすぐに公開できる完璧なシステムになると確信していた。Obsidianで執筆に集中し、GitHub Actionsの自動化マジックであとは勝手に処理される…そんな美しい計画だったのだが…\n\n頭の中では完璧に回っていた計画だったが、実際には思ったより多くの落とし穴が潜んでいた。\n\n> 誰でもそれっぽい計画はある  ~~殴られるまでは~~\n\n## ソリューション探索\n\n### 最初の計画\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant 개발자 as 👨‍💻 執筆者\nparticipant 옵시디언 as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vaultリポジトリ\nparticipant BlogRepo as 📁 Blogリポジトリ\nparticipant Pages as 🌐 GitHub Pages\n개발자 ->> 옵시디언: ブログ記事作成\n옵시디언 ->> VaultRepo: 同期コミット\nNote over VaultRepo: ブログ記事フィルタリングコミットアクション実行\nVaultRepo ->> BlogRepo: ブログ記事コミット\nNote over BlogRepo: ビルド＆デプロイ\nBlogRepo ->> Pages: 静的サイトデプロイ\nNote over 개발자: ローカルでCSS修正、コミット\n개발자 ->> BlogRepo: 💥 コミットプッシュ試行 (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> 개발자: ❌ REJECTED! remote changes exist <br/> コミット前にpullが必要 → コンフリクトの可能性 (自動コミットと手動修正が混在)\nend\n```\n\n最も懸念していたのは、**自動コミットと手動コミットが一つのリポジトリ内で絡み合う状況**だった。  \nGitHub Actionsが記事を自動でコミット・デプロイしている間に、自分がローカルでCSSやレイアウトを修正したらどうなるか？\n\nおそらくプッシュを試みる瞬間、リモートリポジトリにはすでに自動化が生成したコミットが先に入っているだろう。その場合、`git push`は拒否され、コンフリクトを解決するために再度 `git reset HEAD^ & git pull` をしなければならない面倒な状況が起こる可能性が高い。\n\n記事公開のために作った自動化のせいで、**フルタイムのコンフリクトマネージャー**になりかねなかった。\n\n### 二番目の計画\n根本的な問題の原因は、自動化プロセスでブログ記事を直接メインブランチにコミットしていることだ。\n\nならば、**ビルド時に記事を動的に取得すればどうか？**\n```mermaid\nsequenceDiagram\nautonumber\nparticipant 개발자 as 👨‍💻 執筆者\nparticipant 옵시디언 as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vaultリポジトリ\nparticipant BlogRepo as 📁 Blogリポジトリ\nparticipant Pages as 🌐 GitHub Pages\n\n개발자 ->> 옵시디언: ブログ記事作成\n옵시디언 ->> VaultRepo: 同期コミット\nNote over VaultRepo: 記事保存\n\n개발자 ->> BlogRepo: CSS/レイアウト修正\nBlogRepo ->> BlogRepo: ビルドトリガー\n\nrect rgb(200,250,200)\nNote over BlogRepo: ビルドプロセス開始\nBlogRepo ->> VaultRepo: 記事データfetch (checkout)\nVaultRepo -->> BlogRepo: マークダウンファイル群\nNote over BlogRepo: 前処理＆サイトビルド\nend\n\nBlogRepo ->> Pages: 静的サイトデプロイ\n```\n\n\nこうすれば、**記事リポジトリとブログコードリポジトリが完全に分離**される。各々の領域で独立してコミットし、ビルド時にだけ出会う形だ。コンフリクト？そんなものはそもそも発生し得ない構造だ。\n\nしかしこの構造には致命的な問題があった。**公開リポジトリが非公開リポジトリのデータを取得しなければならない点**だ。これは一般的なセキュリティ原則に反する逆方向アクセスだった。\n\n自分のObsidian Vaultは単なるブログリポジトリではない。個人の日記、業務メモ、プロジェクトアイデア、時には機密情報まで含む自分だけのデジタル脳だ。そんな個人リポジトリに公開ブログがアクセスすること自体が不安だった。\n\n- 公開リポジトリのActionsログに機密情報が露出する可能性\n- トークンが盗まれた場合Vault全体が危険に晒されるセキュリティ問題\n- 誤って非公開ファイルがビルド過程に含まれるリスク\n\n何より自分を信用できないため、この計画は破棄された。\n\n### 最終案 \n~~修正版-v3-v3修正-最後-本当の最後.doc~~\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> 記事公開システム ~~人類~~ 補完計画最終版\n\n頭をひねった結果、自分なりの答えを見つけることに成功した。**最初の計画通りブログリポジトリに自動でコミットするが、別のブランチを使えばどうか？**\n\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidianノート\"]\n B[\"GitHub Actions\"]\n C[\"前処理＆翻訳\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-syncブランチ\"]\n E[\"masterブランチ\"]\n F[\"Github Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"ブログデザイン修正\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"Github Page\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nこの構造では：\n- VaultのGitHub Actionsが記事を処理しブログリポジトリの `auto-sync` ブランチにプッシュ\n- ブログのビルドプロセスが `master` と `auto-sync` の両方のブランチをチェックアウトしてマージしビルド\n- デザインやコード修正は普段通り `master` ブランチに直接コミット\n\nコンフリクトの余地を根本的に排除しつつ、セキュリティ問題なく二つのリポジトリを繋げる構造だ。\n\n## 実際の実装\n\n開発者は言葉よりコードだろう？以下のコードが上記計画を実現したGitHub Actionsファイルだ。\n\n**Obsidian Vault（非公開リポジトリ）**\n\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # 不要なworkflow再実行を防ぐため特定ファイル変更時のみ実行\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      # brainリポジトリ（現在のリポジトリ）をチェックアウト\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      # ironpark.github.ioのauto-syncブランチをチェックアウト\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n      # pnpmのインストール＆キャッシュ設定（auto-syncブランチ用）\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n      # brainからcontents（auto-syncブランチ）へ全アセットと記事をコピー\n      - name: Sync Contents\n        run: |\n          rm -rf contents/{posts,assets,output}\n          mkdir -p contents/{posts,assets}\n          cp -r brain/2.Areas/Blog/*.md contents/posts/\n          cp -r brain/Z.Assets/* contents/assets/\n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # 変更があればコミット＆プッシュ\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n          fi\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from $(date +'%Y-%m-%d')\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n\n**ブログ（フロント）[リポジトリ](https://github.com/ironpark/ironpark.github.io)**\n\n```yaml\nname: Build and Deploy to Pages\n\non:\n  push:\n    branches: [\"master\"]\n  workflow_dispatch:\n  repository_dispatch:\n    types: [ post-sync ]\n# GITHUB_TOKENの権限設定（GitHub Pagesへのデプロイ許可）\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n# 同時デプロイは一つだけ許可\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\njobs:\n  build:\n    env:\n      GITHUB_TOKEN: ${{ github.token }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/checkout@v4\n        with:\n          path: ./sync\n          ref: auto-sync\n      - uses: actions/configure-pages@v5\n        id: pages\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'pnpm'\n      - name: Copy posts\n        run: |\n          rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n          rm -rf ./static/posts ; mkdir -p ./static/posts\n          cp -r ./sync/output/posts/*.md ./src/content/blog\n          cp -r ./sync/output/static/posts/* ./static/posts\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n      - name: Build\n        run: pnpm run build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./build\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n      - uses: actions/deploy-pages@v4\n        id: deployment\n```\n\n### 詳しく見てみる\n\nいくら開発者はコードで語ると言っても、コードだけ置いて消えるのは味気ない。もし試してみたい誰かのために、二つのGitHub Actionsワークフローがどう有機的に動くのか一つずつ解剖してみよう。見た目は複雑そうでも、それぞれの役割ははっきり分かれているので、順を追えば理解できるはずだ。\n\n#### Vaultリポジトリワークフロー分析\n\nまずObsidian Vaultリポジトリの `Contents Sync` ワークフローから見てみよう。\n\n**トリガー条件設定**\n```yaml\non:\n  workflow_dispatch:            # 手動実行可能\n  push:\n    paths:\n      - \"2.Areas/Blog/*.md\"     # ブログ記事変更時のみ\n      - \".github/workflows/**\"  # ワークフローファイル変更時\n    branches:\n      - main\n```\n\n`paths`フィルターを使い、**ブログ関連ファイルが変更されたときだけ**実行されるようにした。こうすることで不要なビルドを防ぎ、GitHub Actions無料枠（月2,000分）を節約できる。もちろん `.gitignore` を適切に設定し、不要なファイルがそもそもコミットされないようにするのも必須だ。\n\n**二つのリポジトリ同時チェックアウト**\n```yaml\n- name: Checkout brain repository\n  uses: actions/checkout@v4\n  with:\n    path: brain     # 現リポジトリ（vault）をbrainフォルダにチェックアウト\n    \n- name: Checkout contents repository\n  uses: actions/checkout@v4\n  with:\n    repository: ironpark/ironpark.github.io # ブログのGitHubリポジトリから\n    ref: auto-sync  # auto-syncブランチを\n    path: contents  # contentsフォルダにチェックアウト\n    token: ${{ secrets.GH_TOKEN }}  # 外部リポジトリアクセストークン\n```\n\n一つのワークフロー内で**二つのリポジトリを別パスにチェックアウト**する。こうすれば単純な `cp` コマンドでファイルを移動でき、複雑なスクリプトなしで簡単に同期できる。このときトークンを設定するのは後のコミット・プッシュ作業のためだ。\n\n**記事前処理過程**\n```yaml\n- name: Sync Contents  # 既存ファイル削除、ディレクトリ作成、記事Markdownファイル＆画像コピー\n  run: |\n    rm -rf contents/{posts,assets,output}\n    mkdir -p contents/{posts,assets}\n    cp -r brain/2.Areas/Blog/*.md contents/posts/\n    cp -r brain/Z.Assets/* contents/assets/\n\n- name: Build Contents # 前処理実行（Obsidian文法変換、翻訳など）\n  working-directory: contents\n  run: |\n    pnpm build\n```\n\nまずVaultから**Markdownファイルと画像**をブログリポジトリ（auto-syncブランチ）にコピーする。  \nその後 `pnpm build` で前処理器を実行する。\n\nこの前処理器は以下の作業を行い、その結果をoutputフォルダに保存する\n- Obsidianの `![[image.png]]` 文法を標準Markdownに変換\n- AI翻訳処理（多言語対応）\n- その他前処理作業\n\nこの前処理器もこのブログ構築の核心的役割を担っているが、ここでは詳細は割愛する。\n\n**変更確認と条件付きプッシュ**\n```yaml\n- name: Check for changes\n  id: check_changes\n  run: |\n    git add .\n    if git diff --staged --quiet; then\n      echo \"changes=false\" >> $GITHUB_OUTPUT\n    else\n      echo \"changes=true\" >> $GITHUB_OUTPUT\n    fi\n\n- name: Push Contents\n  if: steps.check_changes.outputs.changes == 'true'  # 変更がある場合のみ\n```\n\n前処理器実行後に実際に変更があった場合のみコミットする。この部分は単に保存しただけで内容が変わっていなければ不要なコミット試行とその後のデプロイ試行を防ぐために存在する。\n\n**ブログビルドトリガー**\n```yaml\n- name: Run Publish\n  run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n```\n\nGitHub CLIを使いブログリポジトリに `repository_dispatch` イベントを発生させる。これが二つのワークフローを繋ぐ重要なリンクだ。ここでの `event_type` は「どんな理由でトリガーされたか」を区別するラベルのような役割を持つ。\n\n#### ブログリポジトリワークフロー分析\n\n次にブログリポジトリの `Build and Deploy to Pages` ワークフローを見てみよう。\n\n**多様なトリガー対応**\n```yaml\non:\n  push:\n    branches: [\"master\"]  # コード修正時\n  workflow_dispatch:      # 手動実行\n  repository_dispatch:    \n    types: [ post-sync ]  # Vaultから送られたイベント\n```\n\n3つのトリガーが宣言されており、その中の `repository_dispatch` がVaultリポジトリと繋がる重要なリンクだ。Vaultワークフローからブログデプロイワークフローを起動するために必要。\n\n**二つのブランチマージ**\n```yaml\n- uses: actions/checkout@v4  # masterブランチチェックアウト\n- uses: actions/checkout@v4\n  with:\n    path: ./sync\n    ref: auto-sync  # auto-syncブランチをsyncフォルダに\n    \n- name: Copy posts\n  run: |\n    rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n    rm -rf ./static/posts ; mkdir -p ./static/posts\n    cp -r ./sync/output/posts/*.md ./src/content/blog  # 前処理済み記事コピー\n    cp -r ./sync/output/static/posts/* ./static/posts  # 画像など静的ファイル\n```\n\n`master` ブランチのコードと `auto-sync` ブランチのコンテンツを合わせてビルドする。この方法でコードとコンテンツの完全な分離を実現した。\n\n#### セキュリティ考慮事項\n\n両ワークフローとも `${{ secrets.GH_TOKEN }}` を使用している。このトークンは：\n- Blogリポジトリにのみ読み書き権限を付与\n- 最小限の権限を持つFine-grained PATを使用\n\nこうすることで万が一トークンが漏洩しても被害を最小限に抑えられる。\n\n#### なぜこんなに複雑に？\n\n単に「記事一つ公開するのに何でこんなに複雑にしたのか」と思うかもしれない。しかしこれにより…\n\n1. **完璧な関心の分離**：執筆とコーディングが互いに邪魔しない\n2. **コンフリクトなしの協業**：自動化と手動作業が平和に共存する\n3. **拡張性**：前処理器、翻訳、クロスポスティングなど機能追加が容易\n4. **セキュリティ**：個人Vaultとブログコンテンツの分離\n\n結局、複雑に見えるこのシステムも **執筆にだけ集中したい** という単純な欲求から始まった。時には単純な目標を達成するために複雑な旅路を経ることもあるのだ。\n\n## この投稿で触れなかったこと\n\nObsidianで書いた記事は基本的にMarkdown形式に従うが、そのままブログに適用するのは難しかった。そこで別途前処理器を作らねばならず、その過程で遭遇した様々な問題があった。今回の投稿では触れなかったが、機会があれば別途まとめて公開する予定だ。\n\n1. **Obsidian文法**  \n    Obsidianは独自のMarkdown拡張文法を使う。例えば `![[image.png]]` 形式の画像埋め込みや `[[他のノート]]` のようなウィキリンクは標準Markdownレンダラーではそのまま表示されない。したがってこれを変換する前処理が必須だった。\n    \n2. **画像パスとアセット管理**  \n    Obsidian Vaultの画像ファイルは通常ノートと同じフォルダに保存されるが、ウェブでは一般的に `/assets/images/` のような統合パスを使う。ビルド時に画像を正しい場所にコピーし、パスを修正する作業が必要だった。\n    \n3. **Mermaid Diagram対応**  \n    この投稿ではmermaid.jsを使って図を作成した。しかし静的サイトビルド過程でこれをそのまま表現するには、動的レンダリングをサポートする別の処理方式が必要だった。\n    \n4. **多言語対応とAI翻訳**  \n    ブログを韓国語、英語、日本語で提供したかった。しかし毎回三言語で直接書くのは難しく、自分の外国語能力にも限界があるためAI翻訳を導入した。ただし翻訳過程でMarkdown文法が変形・破損するなど様々な問題があり、プロンプトを何度も修正することがあった。\n\n\n\n> 💡 **前処理器が気になるなら**\n> \n> 非公開リポジトリを除く全コードはすでに [GitHubリポジトリ](https://github.com/ironpark/ironpark.github.io) で確認できる。特に前処理器の実装が気になるなら `auto-sync` ブランチを見てみよう。\n\n\n## 今後の計画\n\n現在は `published` メタデータで公開の有無を管理しているが、今後は予約公開システムを作り「決まった日に静かに記事が上がる」方式を試してみる予定だ。\n\nそれ以外にも一定時間経過後にVelog、Mediumなど他プラットフォームへ自動クロスポスティングしたり、公開と同時にTwitter(X)、LinkedInなどSNSに要約とリンクを流す機能も考えているが、いつ実装するかはまだ未定である。"}