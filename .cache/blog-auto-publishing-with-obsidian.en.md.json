{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"2adc00d93d3fc5253d73e8b1843edeba6180ae27fdba6103555662ce3cc92fd6","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Plausible Plan","description":"A fully automated system that automatically publishes your writing to the website just by writing and saving in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"똑똑한 블로그 만들기","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [[나만의 블로그를 만들다|My Own Blog Creation|previous post]], I talked about the reasons behind creating the blog and the choice of technologies. This time, I want to discuss why publishing even a single post on the blog I built is so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages was **the publishing process itself**.\n\nSince there’s no separate database or server environment, there’s no management page or dedicated editor. As a result, the basic writing flow—drafting → saving → editing → publishing—is not smooth. On top of that, having blog posts and frontend code mixed in one repository is almost a disaster for me, who easily gets sidetracked. That’s why **separation of concerns** was desperately needed.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**The original plan was this:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to a personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident this would be a perfect system where I could write and publish posts instantly from my smartphone, tablet, or desktop. I could focus solely on writing in Obsidian, and the rest would be handled magically by GitHub Actions automation... such a beautiful plan.\n\nAlthough the plan worked perfectly in my head, in reality, there were far more hidden pitfalls than I expected.\n\n> Everyone has a plausible plan — until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as 👨‍💻 Author\nparticipant Obsidian as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault Repository\nparticipant BlogRepo as 📁 Blog Repository\nparticipant Pages as 🌐 GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Blog post filtering commit action runs\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: 💥 Attempt to push commit (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: ❌ REJECTED! remote changes exist <br/> Need to pull before commit → possible conflicts (mix of automated and manual commits)\nend\n```\n\nThe biggest concern was the **entanglement of automated commits and manual commits within the same repository**.  \nWhat happens if GitHub Actions commits and deploys posts automatically while I’m editing CSS or layout locally?\n\nMost likely, the moment I try to push, the remote repository will already contain commits created by automation. In that case, `git push` will be rejected, and I’ll have to go through the tedious process of resolving conflicts by running `git reset HEAD^ & git pull`.\n\nBecause of the automation I set up to publish posts, I almost became a **full-time conflict manager**.\n\n### Second Plan\nThe root cause of the problem was that the automation process committed blog posts directly to the main branch.\n\nSo, what if **posts were fetched dynamically at build time?**\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as 👨‍💻 Author\nparticipant Obsidian as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault Repository\nparticipant BlogRepo as 📁 Blog Repository\nparticipant Pages as 🌐 GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save post\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Build process starts\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocessing & site build\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\nThis way, **the post repository and blog code repository are completely separated**. Each commits independently in their own domain, meeting only at build time. Conflicts? That’s a structure where they simply can’t happen.\n\nHowever, this structure had a fatal flaw: **a public repository would have to fetch data from a private repository**. This is a reverse access that violates common security principles.\n\nMy Obsidian Vault isn’t just a simple blog repository. It’s my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. The idea of a public blog accessing this personal repository was unsettling.\n\n- Sensitive information might be exposed in the public repository’s Actions logs\n- If tokens are stolen, the entire Vault could be compromised\n- Risk of accidentally including private files in the build process\n\nAbove all, because I don’t trust myself, this plan was discarded.\n\n### The Final Plan?\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> The final version of the post publishing system ~~humanity~~ improvement plan\n\nSo I changed my approach. **What if I commit automatically to the blog repository as originally planned, but use a separate branch?**\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"GitHub Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Blog design edits\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"GitHub Pages\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nIn this structure:\n- GitHub Actions in the Vault pushes processed posts to the blog repository’s `auto-sync` branch\n- The blog’s build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code changes are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely linking the two repositories.\n\n## What This Post Didn’t Cover\n\nPosts written in Obsidian basically follow markdown format, but applying them directly to the blog was difficult. So I had to create a separate preprocessor, and encountered several issues along the way. I didn’t cover these here, but I plan to organize and share them separately when I have the chance.\n\n1. **Obsidian Syntax**  \n    Obsidian uses its own markdown extensions. For example, image embeds like `![[image.png]]` or wikilinks like `[[other note]]` don’t render properly in standard markdown renderers. So a preprocessing step to convert these was essential.\n    \n2. **Image Paths and Asset Management**  \n    Images in the Obsidian Vault are usually stored in the same folder as notes, but on the web, unified paths like `/assets/images/` are commonly used. At build time, images needed to be copied to the correct location and paths adjusted.\n    \n3. **Mermaid Diagram Support**  \n    This post used mermaid.js for diagrams. However, to render them properly in a static site build, a separate approach supporting dynamic rendering was necessary.\n    \n4. **Multilingual Support and AI Translation**  \n    I wanted the blog to be available in Korean, English, and Japanese. Writing in all three languages manually was difficult, and my foreign language skills limited, so I introduced AI translation. However, markdown syntax sometimes broke or got distorted during translation, requiring several prompt adjustments.\n\n## Implementation\n```yaml\n\n```\n## Future Plans\n\nCurrently, I manage post publication status with a `published` metadata field, but I plan to build a scheduled publishing system that “quietly posts on a set date.”\n\nAdditionally, I’m considering features like automatically cross-posting to platforms like Velog or Medium after a certain time, or posting summaries and links to social media like Twitter (X) and LinkedIn simultaneously with publication. When these will be implemented is still uncertain.\n\n> It’s still just an idea, but my goal is to squeeze every bit of free tier usage from GitHub Actions. (At this point, it feels less like the machine is being worked hard, and more like I am.)\n\n---\n\n> 💡 **Curious about this automation system?**\n> \n> The full code is available at the [GitHub repository](https://github.com/ironpark/ironpark.github.io).  \n> Especially check out the action files in the `.github/workflows/` folder for detailed implementation.\n>\n> If you want to build a similar system, feel free to ask questions anytime. Let’s create a better writing environment together."}