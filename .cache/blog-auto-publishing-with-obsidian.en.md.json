{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"5408560b366ef29bc687430258eb17267902246d97f8ad103c26208270d447cf","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Pretty Good Plan","description":"A fully automated system that publishes your writings to the website automatically once you write and save in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"ÎòëÎòëÌïú Î∏îÎ°úÍ∑∏ ÎßåÎì§Í∏∞","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [[ÎÇòÎßåÏùò Î∏îÎ°úÍ∑∏Î•º ÎßåÎì§Îã§|My Own Blog Creation|previous post]], I talked about why I decided to create a blog and how I chose the technologies. This time, I want to discuss why publishing even a single post on that blog is so complicated and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages is **the publishing process itself**.\n\nSince there‚Äôs no separate database or server environment, there‚Äôs no management page or dedicated editor. As a result, the basic writing flow ‚Äî draft ‚Üí save ‚Üí edit ‚Üí publish ‚Äî is not smooth. On top of that, having blog posts and frontend code mixed in the same repository is almost a disaster for me, who easily gets sidetracked. So, **separation of concerns** was desperately needed.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**The original plan was this:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to a personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident this would be a perfect system to write and deploy posts instantly from smartphones, tablets, or desktops. Just focus on writing in Obsidian, and let GitHub Actions‚Äô automation magic handle the rest... such a beautiful plan.\n\nAlthough it worked perfectly in my head, in reality, there were more hidden pitfalls than I expected.\n\n> Everyone has a plausible plan ‚Äî until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as üë®‚Äçüíª Author\nparticipant Obsidian as ü™® Obsidian\nparticipant VaultRepo as üìÅ Vault Repository\nparticipant BlogRepo as üìÅ Blog Repository\nparticipant Pages as üåê GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run blog post filtering commit action\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Modify CSS locally, commit\nDeveloper ->> BlogRepo: üí• Attempt commit push (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: ‚ùå REJECTED! remote changes exist <br/> Need to pull before commit ‚Üí possible conflict (mix of auto and manual commits)\nend\n```\n\nThe biggest concern was **the entanglement of automatic commits and manual commits in the same repository**.  \nWhat if GitHub Actions automatically commits and deploys posts while I‚Äôm modifying CSS or layout locally?\n\nMost likely, at the moment I try to push, the remote repository will already have commits created by automation. In that case, `git push` will be rejected, and I‚Äôll have to go through the tedious process of `git reset HEAD^ & git pull` to resolve conflicts.\n\nBecause of automation created to publish posts, I almost became a **full-time conflict manager**.\n\n### Second Plan\nThe root problem was that the automation process committed blog posts directly to the main branch.\n\nSo, what if we **fetch posts dynamically at build time?**\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as üë®‚Äçüíª Author\nparticipant Obsidian as ü™® Obsidian\nparticipant VaultRepo as üìÅ Vault Repository\nparticipant BlogRepo as üìÅ Blog Repository\nparticipant Pages as üåê GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save posts\n\nDeveloper ->> BlogRepo: Modify CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Start build process\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocess & build site\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\nThis completely separates the post repository and the blog code repository. Each commits independently in its own domain and only meets at build time. Conflicts? Such things simply cannot happen in this structure.\n\nHowever, this structure had a fatal flaw: **a public repository had to fetch data from a private repository**. This reversed access goes against common security principles.\n\nMy Obsidian Vault is not just a simple blog repository. It‚Äôs my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. Having a public blog access this personal repository felt inherently unsafe.\n\n- Risk of sensitive information leaking in public repository‚Äôs Actions logs\n- Security risk of entire Vault exposure if token is compromised\n- Risk of accidentally including private files during the build process\n\nAbove all, because I don‚Äôt trust myself, this plan was discarded.\n\n### Final Plan\n~~Revision-v3-v3final-last-reallyfinal.doc~~\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> Final version of the post publishing system ~~humanity~~ enhancement plan\n\nAfter much thinking, I found my own answer. **What if we commit automatically to the blog repository as originally planned, but use a separate branch?**\n\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"GitHub Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Blog design modification\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"GitHub Pages\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nIn this structure:\n- GitHub Actions in the Vault processes posts and pushes to the blog repository‚Äôs `auto-sync` branch\n- The blog‚Äôs build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code modifications are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely connecting the two repositories.\n\n## Actual Implementation\n\nDevelopers speak with code, don‚Äôt they? Below is the GitHub Actions file that implements the above plan.\n\n**Obsidian Vault (Private Repository)**\n\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # Run only when specific files change to avoid unnecessary workflow reruns\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      # Checkout brain repository (current repository)\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      # Checkout auto-sync branch of ironpark.github.io\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n      # Install pnpm & cache settings for auto-sync branch of ironpark.github.io\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n      # Copy all assets and posts from brain to contents (auto-sync branch)\n      - name: Sync Contents\n        run: |\n          rm -rf contents/{posts,assets,output}\n          mkdir -p contents/{posts,assets}\n          cp -r brain/2.Areas/Blog/*.md contents/posts/\n          cp -r brain/Z.Assets/* contents/assets/\n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # Check for changes in contents and push if there are any changes\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n          fi\n      # Push Contents if there are any changes\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from $(date +'%Y-%m-%d')\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n\n**Blog (Frontend) [Repository](https://github.com/ironpark/ironpark.github.io)**\n\n```yaml\nname: Build and Deploy to Pages\n\non:\n  push:\n    branches: [\"master\"]\n  workflow_dispatch:\n  repository_dispatch:\n    types: [ post-sync ]\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n# Allow one concurrent deployment\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\njobs:\n  build:\n    env:\n      GITHUB_TOKEN: ${{ github.token }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/checkout@v4\n        with:\n          path: ./sync\n          ref: auto-sync\n      - uses: actions/configure-pages@v5\n        id: pages\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'pnpm'\n      - name: Copy posts\n        run: |\n          rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n          rm -rf ./static/posts ; mkdir -p ./static/posts\n          cp -r ./sync/output/posts/*.md ./src/content/blog\n          cp -r ./sync/output/static/posts/* ./static/posts\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n      - name: Build\n        run: pnpm run build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./build\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n      - uses: actions/deploy-pages@v4\n        id: deployment\n```\n\n### A Closer Look\n\nNo matter how much developers speak with code, just dropping code and disappearing feels too cold. For anyone who might want to try this, let me dissect how these two GitHub Actions workflows work together.\n\nThough it looks complicated at first glance, each has a clear role, so read on step by step.\n\n#### Vault Repository Workflow Analysis\n\nFirst, the `Contents Sync` workflow in the Obsidian Vault repository.\n\n**Trigger Conditions**\n```yaml\non:\n  workflow_dispatch:            # Can be run manually\n  push:\n    paths:\n      - \"2.Areas/Blog/*.md\"     # Only when blog posts change\n      - \".github/workflows/**\"  # Or workflow files change\n    branches:\n      - main\n```\n\nUsing the `paths` filter, it runs **only when blog-related files change**. This prevents unnecessary builds and saves GitHub Actions free tier minutes (2,000 minutes/month). Also, don‚Äôt forget to set `.gitignore` properly so unnecessary files don‚Äôt get committed in the first place.\n\n**Checking out Two Repositories Simultaneously**\n```yaml\n- name: Checkout brain repository\n  uses: actions/checkout@v4\n  with:\n    path: brain     # Check out current repo (vault) into brain folder\n    \n- name: Checkout contents repository\n  uses: actions/checkout@v4\n  with:\n    repository: ironpark/ironpark.github.io # From blog‚Äôs GitHub repo\n    ref: auto-sync  # auto-sync branch\n    path: contents  # into contents folder\n    token: ${{ secrets.GH_TOKEN }}  # Token for external repo access\n```\n\nThis workflow checks out **two repositories into different paths**. This allows simple `cp` commands to move files, enabling easy synchronization without complex scripts. The token is set to allow commit and push later.\n\n**Post Preprocessing**\n```yaml\n- name: Sync Contents  # Remove old files, create directories, copy markdown posts & images\n  run: |\n    rm -rf contents/{posts,assets,output}\n    mkdir -p contents/{posts,assets}\n    cp -r brain/2.Areas/Blog/*.md contents/posts/\n    cp -r brain/Z.Assets/* contents/assets/\n\n- name: Build Contents # Run preprocessing (Obsidian syntax conversion, translation, etc.)\n  working-directory: contents\n  run: |\n    pnpm build\n```\n\nFirst, markdown files and images are copied from Vault to the blog repository‚Äôs `auto-sync` branch. Then `pnpm build` runs the preprocessor inside the blog repo.\n\nThis preprocessor performs:\n- Conversion of Obsidian‚Äôs `![[image.png]]` syntax to standard markdown\n- AI translation (multilingual support)\n- Other preprocessing tasks...\n\nThis preprocessor is a core part of this blog‚Äôs setup but I‚Äôll skip details for now.\n\n**Checking for Changes and Conditional Push**\n```yaml\n- name: Check for changes\n  id: check_changes\n  run: |\n    git add .\n    if git diff --staged --quiet; then\n      echo \"changes=false\" >> $GITHUB_OUTPUT\n    else\n      echo \"changes=true\" >> $GITHUB_OUTPUT\n    fi\n\n- name: Push Contents\n  if: steps.check_changes.outputs.changes == 'true'  # Only if changes exist\n```\n\nAfter preprocessing, it commits only if there are actual changes. This avoids unnecessary commits and deployments if content hasn‚Äôt changed.\n\n**Triggering Blog Build**\n```yaml\n- name: Run Publish\n  run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n```\n\nUsing GitHub CLI, it triggers a `repository_dispatch` event on the blog repository. This is the key link connecting the two workflows. The `event_type` acts like a label to distinguish why the trigger happened.\n\n#### Blog Repository Workflow Analysis\n\nNow, let‚Äôs look at the blog repository‚Äôs `Build and Deploy to Pages` workflow.\n\n**Supporting Multiple Triggers**\n```yaml\non:\n  push:\n    branches: [\"master\"]  # When code changes\n  workflow_dispatch:      # Manual run\n  repository_dispatch:    \n    types: [ post-sync ]  # Event sent from Vault\n```\n\nThree triggers are declared, among which `repository_dispatch` is the important link to the Vault repository. The Vault workflow uses this to trigger the blog deployment workflow.\n\n**Merging Two Branches**\n```yaml\n- uses: actions/checkout@v4  # Checkout master branch\n- uses: actions/checkout@v4\n  with:\n    path: ./sync\n    ref: auto-sync  # Checkout auto-sync branch into sync folder\n    \n- name: Copy posts\n  run: |\n    rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n    rm -rf ./static/posts ; mkdir -p ./static/posts\n    cp -r ./sync/output/posts/*.md ./src/content/blog  # Copy preprocessed posts\n    cp -r ./sync/output/static/posts/* ./static/posts  # Static files like images\n```\n\nIt builds by combining the code from the `master` branch and the content from the `auto-sync` branch. This achieves perfect separation of code and content.\n\n#### Security Considerations\n\nBoth workflows use `${{ secrets.GH_TOKEN }}`. This token is:\n- Granted read/write permissions only on the Blog repo\n- A fine-grained PAT with minimal permissions\n\nThis minimizes damage even if the token is accidentally exposed.\n\n#### Why So Complicated?\n\nYou might wonder, ‚ÄúWhy make it so complicated just to publish a single post?‚Äù But what I gained from this complexity is far from trivial.\n\n1. **Perfect separation of concerns**: Writing and coding don‚Äôt interfere\n2. **Conflict-free collaboration**: Automation and manual work coexist peacefully\n3. **Extensibility**: Easy to add features like preprocessors, translation, cross-posting\n4. **Security**: Separation between personal Vault and blog content\n\nUltimately, this seemingly complex system started from a simple desire to **focus solely on writing**. Sometimes, achieving a simple goal requires a complicated journey.\n\n## What‚Äôs Not Covered\n\nPosts written in Obsidian basically follow markdown format, but applying them directly to the blog was difficult. So I had to create a separate preprocessor and faced various issues during that process. I didn‚Äôt cover those in this post but plan to write about them separately when I get the chance.\n\n1. **Obsidian Syntax**  \n    Obsidian uses its own markdown extensions. For example, image embeds like `![[image.png]]` or wikilinks like `[[Other Note]]` don‚Äôt render properly in standard markdown renderers. So a preprocessing step to convert these was essential.\n    \n2. **Image Paths and Asset Management**  \n    Obsidian Vault stores image files usually in the same folder as notes, but on the web, unified paths like `/assets/images/` are commonly used. At build time, images had to be copied to the correct location and paths adjusted.\n    \n3. **Mermaid Diagram Support**  \n    This post uses mermaid.js for diagrams. I created custom components to support this, but for some reason it didn‚Äôt render properly. So I switched to generating SVG files during preprocessing.\n    \n4. **Multilingual Support and AI Translation**  \n    I wanted the blog to support Korean, English, and Japanese. Writing all three languages manually every time was hard, and my foreign language skills are limited, so I introduced AI translation. However, markdown syntax sometimes got corrupted during translation, requiring multiple prompt refinements.\n\n## Future Plans\n\nCurrently, post publication is managed by `published` metadata, but I plan to create a scheduled publishing system that ‚Äúquietly posts on a set date.‚Äù\n\nBesides that, I‚Äôm considering automatic cross-posting to platforms like Velog and Medium after a certain time, or posting summaries and links to social media like Twitter (X) and LinkedIn upon publishing. But when or if these will be implemented is still unknown.\n\n> üí° **If you want to know more**\n> \n> The entire code except for the private Vault repository is already available at the [GitHub repository](https://github.com/ironpark/ironpark.github.io). If you‚Äôre curious about the preprocessor implementation, check out the `auto-sync` branch."}