{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"940f9825842a66a2e6f80e144ed574ed5f0410895a0b55d127219638cc414e92","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Plausible Plan","description":"A fully automated system that automatically publishes your writing to the website just by writing and saving in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"ë˜‘ë˜‘í•œ ë¸”ë¡œê·¸ ë§Œë“¤ê¸°","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [[ë‚˜ë§Œì˜ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ë‹¤|Last Post]], I talked about the reasons for creating my own blog and the rationale behind the technology choices. This time, I want to discuss why publishing even a single post on that blog is so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages was **the publishing process itself**.\n\nSince there is no separate database or server environment, there is no management page or dedicated editor. As a result, the basic writing flow of draft â†’ save â†’ edit â†’ publish is not smooth. Moreover, having blog posts and frontend code mixed in one repository is almost a disaster for me, who easily gets sidetracked. Thatâ€™s why **separation of concerns** was desperately needed.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**The original plan was this:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to my personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident this would be a perfect system where I could write and deploy posts instantly from my smartphone, tablet, or desktop. I would focus solely on writing in Obsidian, and GitHub Actionsâ€™ automation magic would handle the rest... such a beautiful plan.\n\nAlthough it worked perfectly in my head, in reality, there were more hidden pitfalls than I expected.\n\n> Everyone has a plausible plan â€” until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run blog post filtering commit action\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: ğŸ’¥ Attempt to push commit (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: âŒ REJECTED! remote changes exist <br/> Pull required before commit â†’ possible conflicts (mix of automated and manual commits)\nend\n```\n\nThe biggest concern was the **entanglement of automated commits and manual commits within one repository**.  \nWhat happens if GitHub Actions automatically commits and deploys posts while Iâ€™m editing CSS or layout locally?\n\nMost likely, the moment I try to push, the remote repository will already contain commits created by automation. In that case, `git push` will be rejected, and Iâ€™ll have to go through the tedious process of `git reset HEAD^ & git pull` to resolve conflicts.\n\nBecause of the automation I built to publish posts, I almost became a **full-time conflict manager**.\n\n### Second Plan\nThe root cause was that the automation process committed blog posts directly to the main branch.\n\nSo, what if **posts were fetched dynamically at build time?**\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Store post\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Start build process\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocess & build site\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\n\nThis completely separates the post repository and the blog code repository. Each commits independently in their own domain, meeting only at build time. Conflicts? That structure makes them impossible.\n\nBut this structure had a fatal flaw: **a public repository would have to fetch data from a private repository**. This is a reverse access that violates common security principles.\n\nMy Obsidian Vault is not just a blog repository. It is my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. The idea of a public blog accessing such a personal repository was unsettling.\n\n- Risk of sensitive information leaking in public repositoryâ€™s Actions logs\n- Security risk of the entire Vault being exposed if tokens are compromised\n- Risk of accidentally including private files in the build process\n\nMost of all, because I donâ€™t trust myself, this plan was discarded.\n\n### The Final?\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> Post publishing system ~~humanity~~ improvement plan final version\n\nSo I changed my approach. **What if I automatically commit to the blog repository as originally planned, but use a separate branch?**\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"GitHub Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Blog design edits\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"GitHub Pages\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nIn this structure:\n- GitHub Actions in the Vault pushes processed posts to the blog repositoryâ€™s `auto-sync` branch\n- The blogâ€™s build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code edits are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely connecting the two repositories.\n\n## What This Post Didnâ€™t Cover\n\nAlthough posts written in Obsidian basically follow Markdown format, applying them directly to the blog was difficult. So I had to create a separate preprocessor, and encountered several issues during that process. I didnâ€™t cover them here, but I plan to write about them separately when I get the chance.\n\n1. **Obsidian Syntax**  \n    Obsidian uses its own Markdown extensions. For example, image embeds like `![[image.png]]` or wikilinks like `[[another note]]` donâ€™t render properly in standard Markdown renderers. So a preprocessing step to convert these was essential.\n    \n2. **Image Paths and Asset Management**  \n    Images in the Obsidian Vault are usually stored in the same folder as notes, but on the web, unified paths like `/assets/images/` are commonly used. At build time, images had to be copied to the correct location and paths adjusted.\n    \n3. **Mermaid Diagram Support**  \n    This post used mermaid.js for diagrams. However, to render these properly in a static site build, a separate approach supporting dynamic rendering was needed.\n    \n4. **Multilingual Support and AI Translation**  \n    I wanted to offer the blog in Korean, English, and Japanese. Writing in all three languages manually every time was difficult, and my foreign language skills are limited, so I introduced AI translation. However, there were various issues such as Markdown syntax breaking or being altered during translation, requiring multiple prompt adjustments.\n\n## Implementation\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # Run only when specific files change to avoid unnecessary workflow reruns\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Get current date\n        id: date\n        run: echo \"::set-output name=date::$(date +'%Y-%m-%d')\"\n      # Checkout brain repository (current repository)\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      \n      # Checkout auto-sync branch of ironpark.github.io\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n\n      # Install pnpm & cache settings for auto-sync branch of ironpark.github.io\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n\n      - name: Sync Contents\n        run: |\n          # Clean up old contents (posts, assets, output)\n          rm -rf /contents/{posts,assets,output}\n          \n          # Create directories and copy files\n          mkdir -p /contents/{posts,assets}\n          cp -r /brain/2.Areas/Blog/*.md /contents/posts/ 2>/dev/null || echo \"No markdown files found\"\n          cp -r /brain/Z.Assets/* /contents/assets/* 2>/dev/null || echo \"No image assets found\"\n      \n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # Check for changes in contents and push if there are any changes\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n            echo \"No changes detected\"\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n            echo \"Changes detected\"\n          fi\n      # Push Contents if there are any changes\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from ${{ steps.date.outputs.date }}\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n## Future Plans\n\nCurrently, publication status is managed with the `published` metadata, but I plan to build a scheduled publishing system that â€œquietly posts articles on predetermined dates.â€\n\nIâ€™m also considering automatic cross-posting to other platforms like Velog or Medium after a certain period, or posting summaries and links to social media like Twitter (X) and LinkedIn simultaneously with publication. However, when or if these will be implemented is still uncertain.\n\n> For now, itâ€™s just an idea, but my goal is to squeeze every bit out of GitHub Actionsâ€™ free tier. (At this point, it feels less like the machine is working and more like Iâ€™m being overworked.)\n\n---\n\n> ğŸ’¡ **If youâ€™re curious about this automation system**\n> \n> The full code is available on the [GitHub repository](https://github.com/ironpark/ironpark.github.io).  \n> Especially check out the action files in the `.github/workflows/` folder for detailed implementation.\n>\n> If you want to build a similar system, feel free to ask questions anytime. Letâ€™s create a better writing environment together."}