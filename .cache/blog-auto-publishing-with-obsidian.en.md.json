{"metadataHash":"9af9c6c0ef42897a047f2ba9a53b1e05318996ed65ee9b9c7aa1b36648286e6a","contentHash":"bfe796dd736e57cf1c456541b6409483b676c3ae010198d1e38b2bb0c48aac55","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-09-03T12:42:24.000Z","published":"2025-08-09T14:13:00.000Z","slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Pretty Good Plan","description":"A fully automated system that publishes your writing to the website automatically whenever you write and save in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"똑똑한 블로그 만들기","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [[나만의 블로그를 만들다|Last Post]], I talked about why I created my blog and the reasoning behind my technology choices. This time, I want to discuss why publishing even a single post on that blog is so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages was **the publishing process itself**.\n\nSince there’s no separate database or server environment, there’s no management page or dedicated editor. As a result, the basic writing flow—drafting → saving → editing → publishing—is not smooth. Moreover, having blog posts and frontend code mixed in the same repository is almost a disaster for someone like me who easily gets sidetracked. That’s why **separation of concerns** was desperately needed.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**The original plan was:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to a personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident this would create a perfect system where I could write and deploy posts immediately from my smartphone, tablet, or desktop. I’d just focus on writing in Obsidian, and the rest would be handled magically by GitHub Actions automation... such a beautiful plan.\n\nThough it worked perfectly in my head, in reality, many hidden pitfalls emerged.\n\n> Everyone has a plausible plan — until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as 👨‍💻 Author\nparticipant Obsidian as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault Repository\nparticipant BlogRepo as 📁 Blog Repository\nparticipant Pages as 🌐 GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run blog post filtering commit action\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: 💥 Attempt commit push (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: ❌ REJECTED! remote changes exist <br/> Need to pull before commit → possible conflicts (mix of auto and manual commits)\nend\n```\n\nThe biggest concern was **the entanglement of automatic commits and manual commits in the same repository**.  \nWhat happens if GitHub Actions automatically commits and deploys posts while I’m editing CSS or layout locally?\n\nMost likely, when I try to push, the remote repository will already have commits created by automation. In that case, `git push` will be rejected, and I’ll have to go through the hassle of `git reset HEAD^ & git pull` to resolve conflicts.\n\nBecause of automation meant to publish posts, I almost became a **full-time conflict manager**.\n\n### Second Plan\n\nThe root cause of the problem was that the automation process was committing blog posts directly to the main branch.\n\nSo, what if **posts were fetched dynamically at build time?**\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as 👨‍💻 Author\nparticipant Obsidian as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault Repository\nparticipant BlogRepo as 📁 Blog Repository\nparticipant Pages as 🌐 GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save post\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Start build process\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocess & build site\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\nThis completely separates the post repository and the blog code repository. Each commits independently in their own domain and only meet at build time. Conflicts? Such a thing simply cannot happen in this structure.\n\nHowever, this structure had a fatal flaw: **a public repository would have to fetch data from a private repository**. This is a reverse access pattern that violates common security principles.\n\nMy Obsidian Vault is not just a simple blog repository. It’s my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. Having a public blog access this personal repository felt unsettling.\n\n- Risk of sensitive information leaking in public repository’s Actions logs\n- Security risk of exposing the entire Vault if tokens are stolen\n- Risk of accidentally including private files in the build process\n\nMost of all, because I don’t trust myself, this plan was discarded.\n\n### Final Plan  \n~~Revision-v3-v3final-last-final.doc~~\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> Post publishing system ~~Humanity~~ Enhancement Plan Final Version\n\nAfter thinking hard, I found my own answer. What if I automatically commit to the blog repository as originally planned, but use a separate branch?\n\n```mermaid\nflowchart TB\n    %% User area\n    subgraph User[\"👤 User Workspace\"]\n        direction LR\n        obsidian[\"📝 Obsidian<br/>Note Writing\"]\n        editSrc[\"🎨 Blog<br/>Design/Feature Editing\"]\n    end\n\n    %% Private Vault repository\n    subgraph PrivateVault[\"🔒 Private Vault Repository\"]\n        mainBranch[\"📌 main branch<br/>(Content Storage)\"]\n        \n        subgraph VaultActions[\"⚙️ GitHub Actions\"]\n\t        direction TB\n            vaultTrigger{{\"🔔 Push Event<br/>Detected\"}}\n            processContent[\"📋 Process Content\"]\n            commitPush[\"📤 Commit & Push<br/>to auto-sync\"]\n            triggerPublic[\"🚀 Trigger Public Action\"]\n            \n            vaultTrigger --> processContent\n            processContent --> commitPush\n            commitPush --> triggerPublic\n        end\n    end\n\n    %% Public Blog repository\n    subgraph PublicBlog[\"🌐 Public Blog Repository\"]\n        masterBranch[\"🏠 master branch<br/>(Blog Source)\"]\n        autosyncBranch[\"🔄 auto-sync branch<br/>(Content Sync)\"]\n        \n        subgraph BlogActions[\"⚙️ GitHub Actions\"]\n            blogTrigger{{\"🔔 Trigger Event<br/>Detected\"}}\n            checkoutBranches[\"📥 Checkout<br/>master + auto-sync\"]\n            mergeBranches[\"🔨 Merge & Build\"]\n            blogTrigger --> checkoutBranches\n            checkoutBranches --> mergeBranches\n        end\n    end\n\n    %% Final result\n    pages[\"🌍 GitHub Pages<br/>(Live Blog)\"]\n\n    %% Connections\n    obsidian -.->|\"Write/Edit Notes\"| mainBranch\n    editSrc -.->|\"Direct Push\"| masterBranch\n    \n    mainBranch -->|\"Push Event\"| vaultTrigger\n    commitPush -->|\"Auto Push\"| autosyncBranch\n    triggerPublic -.->|\"Repository Dispatch\"| blogTrigger\n    \n    masterBranch -.->|\"Source Code\"| checkoutBranches\n    autosyncBranch -.->|\"Content\"| checkoutBranches\n    mergeBranches -->|\"🚢 Deploy\"| pages\n\n    %% Styling\n    classDef userStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#01579b\n    classDef privateStyle fill:#fce4ec,stroke:#880e4f,stroke-width:2px,color:#880e4f\n    classDef publicStyle fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px,color:#1b5e20\n    classDef actionStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#e65100\n    classDef resultStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#4a148c\n    \n    class User userStyle\n    class PrivateVault privateStyle\n    class PublicBlog publicStyle\n    class VaultActions,BlogActions actionStyle\n    class pages resultStyle\n```\n\n- Vault’s GitHub Actions process posts and push to the blog repository’s `auto-sync` branch\n- Blog’s build process checks out both `master` and `auto-sync` branches, merges, then builds\n- Design or code edits are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely connecting the two repositories.\n\n## The Plan Is Perfect\n\n### Actual Implementation\n\nDevelopers speak with code, don’t they? Below is the GitHub Actions file that realizes the above plan.\n\n**Obsidian Vault (Private Repository)**\n\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # To avoid unnecessary workflow re-runs, only run when specific files change\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      # Checkout brain repository (current repository)\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      # Checkout auto-sync branch of ironpark.github.io\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n      # Install pnpm & cache settings for auto-sync branch of ironpark.github.io\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n      # Copy all assets and posts from brain to contents (auto-sync branch)\n      - name: Sync Contents\n        run: |\n          rm -rf contents/{posts,assets,output}\n          mkdir -p contents/{posts,assets}\n          cp -r brain/2.Areas/Blog/*.md contents/posts/\n          cp -r brain/Z.Assets/* contents/assets/\n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # Check for changes in contents and push if there are any changes\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n          fi\n      # Push Contents if there are any changes\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from $(date +'%Y-%m-%d')\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n\n**Blog (Frontend) [Repository](https://github.com/ironpark/ironpark.github.io)**\n\n```yaml\nname: Build and Deploy to Pages\n\non:\n  push:\n    branches: [\"master\"]\n  workflow_dispatch:\n  repository_dispatch:\n    types: [ post-sync ]\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n# Allow one concurrent deployment\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\njobs:\n  build:\n    env:\n      GITHUB_TOKEN: ${{ github.token }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/checkout@v4\n        with:\n          path: ./sync\n          ref: auto-sync\n      - uses: actions/configure-pages@v5\n        id: pages\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'pnpm'\n      - name: Copy posts\n        run: |\n          rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n          rm -rf ./static/posts ; mkdir -p ./static/posts\n          cp -r ./sync/output/posts/*.md ./src/content/blog\n          cp -r ./sync/output/static/posts/* ./static/posts\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n      - name: Build\n        run: pnpm run build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./build\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n      - uses: actions/deploy-pages@v4\n        id: deployment\n```\n\n### Taking a Closer Look\n\nNo matter how much developers speak with code, it feels too cold to just drop code and disappear. For anyone who might want to try this, let’s dissect how these two GitHub Actions workflows work together.\n\nThough it looks complicated at first glance, each has a clear role, so read on step by step.\n\n#### Vault Repository Workflow Analysis\n\nFirst, the `Contents Sync` workflow in the Obsidian Vault repository.\n\n**Trigger Conditions**\n```yaml\non:\n  workflow_dispatch:            # Can be run manually\n  push:\n    paths:\n      - \"2.Areas/Blog/*.md\"     # Only when blog posts change\n      - \".github/workflows/**\"  # Or workflow files change\n    branches:\n      - main\n```\n\nUsing the `paths` filter, it runs **only when blog-related files change**. This prevents unnecessary builds and saves GitHub Actions free tier minutes (2,000 per month). Also, don’t forget to set `.gitignore` properly so unnecessary files aren’t committed in the first place.\n\n**Checking out Both Repositories Simultaneously**\n```yaml\n- name: Checkout brain repository\n  uses: actions/checkout@v4\n  with:\n    path: brain     # Check out current repo (vault) into brain folder\n    \n- name: Checkout contents repository\n  uses: actions/checkout@v4\n  with:\n    repository: ironpark/ironpark.github.io # From blog’s GitHub repo\n    ref: auto-sync  # auto-sync branch\n    path: contents  # into contents folder\n    token: ${{ secrets.GH_TOKEN }}  # Token for external repo access\n```\n\nWithin one workflow, **two repositories are checked out into different paths**. This allows simple `cp` commands to move files without complex scripts. The token is set for later commit and push operations.\n\n**Post Preprocessing**\n```yaml\n- name: Sync Contents  # Remove old files, create directories, copy markdown posts & images\n  run: |\n    rm -rf contents/{posts,assets,output}\n    mkdir -p contents/{posts,assets}\n    cp -r brain/2.Areas/Blog/*.md contents/posts/\n    cp -r brain/Z.Assets/* contents/assets/\n\n- name: Build Contents # Run preprocessing (Obsidian syntax conversion, translation, etc.)\n  working-directory: contents\n  run: |\n    pnpm build\n```\n\nFirst, markdown files and images from the Vault are copied into the blog repository’s `auto-sync` branch. Then `pnpm build` runs the preprocessor in the blog repo.\n\nThis preprocessor performs tasks like:\n- Converting Obsidian’s `![[image.png]]` syntax to standard markdown\n- AI translation (for multilingual support)\n- Other preprocessing tasks\n\nThis preprocessor plays a key role in building this blog but I’ll skip the details for now.\n\n**Checking for Changes and Conditional Push**\n```yaml\n- name: Check for changes\n  id: check_changes\n  run: |\n    git add .\n    if git diff --staged --quiet; then\n      echo \"changes=false\" >> $GITHUB_OUTPUT\n    else\n      echo \"changes=true\" >> $GITHUB_OUTPUT\n    fi\n\n- name: Push Contents\n  if: steps.check_changes.outputs.changes == 'true'  # Only if there are changes\n```\n\nAfter preprocessing, it commits only if there are actual changes. This prevents unnecessary commits and deployments when nothing has changed.\n\n**Triggering Blog Build**\n```yaml\n- name: Run Publish\n  run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n```\n\nThis uses GitHub CLI to trigger a `repository_dispatch` event in the blog repository. This is the key link connecting the two workflows. The `event_type` acts as a label to indicate why the trigger happened.\n\n#### Blog Repository Workflow Analysis\n\nNow, let’s look at the blog repository’s `Build and Deploy to Pages` workflow.\n\n**Supports Multiple Triggers**\n```yaml\non:\n  push:\n    branches: [\"master\"]  # When code changes\n  workflow_dispatch:      # Manual run\n  repository_dispatch:    \n    types: [ post-sync ]  # Event sent from Vault\n```\n\nThere are three triggers declared. Among them, `repository_dispatch` is the crucial link to the Vault repository. It’s needed to run the blog deployment workflow from the Vault workflow.\n\n**Merging Two Branches**\n```yaml\n- uses: actions/checkout@v4  # Checkout master branch\n- uses: actions/checkout@v4\n  with:\n    path: ./sync\n    ref: auto-sync  # Checkout auto-sync branch into sync folder\n    \n- name: Copy posts\n  run: |\n    rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n    rm -rf ./static/posts ; mkdir -p ./static/posts\n    cp -r ./sync/output/posts/*.md ./src/content/blog  # Copy preprocessed posts\n    cp -r ./sync/output/static/posts/* ./static/posts  # Static files like images\n```\n\nIt merges the code from the `master` branch and the content from the `auto-sync` branch to build the site. Finally, the perfect separation of code and content is achieved.\n\n#### Security Considerations\n\nBoth workflows use `${{ secrets.GH_TOKEN }}`. This token:\n\n- Grants read/write permission only to the blog repo\n- Uses a fine-grained PAT with minimal permissions\n\nThis minimizes damage even if the token is accidentally exposed.\n\n### Why So Complicated?\n\nYou might wonder, “Why make it so complicated just to publish a single post?” But the benefits gained are far from trivial.\n\n1. **Perfect separation of concerns**: Writing and coding don’t interfere with each other  \n2. **Conflict-free collaboration**: Automation and manual work coexist peacefully  \n3. **Extensibility**: Easy to add features like preprocessors, translation, cross-posting  \n4. **Security**: Clear separation between personal Vault and blog content\n\nIn the end, this seemingly complex system started from a simple desire to **just focus on writing**. Sometimes, achieving a simple goal requires a complex journey.\n\n## What’s Not Covered\n\nPosts written in Obsidian basically follow markdown format, but applying them directly to the blog was difficult. So I had to create a separate preprocessor and encountered various issues along the way. I didn’t cover them here, but I plan to write about them separately when I get the chance.\n\n1. **Obsidian Syntax**  \n    Obsidian uses its own markdown extensions. For example, image embeds like `![[image.png]]` or wikilinks like `[[Other Note]]` don’t render properly in standard markdown renderers. So a preprocessing step to convert these was essential.\n    \n2. **Image Paths and Asset Management**  \n    Obsidian Vault images are usually stored in the same folder as notes, but on the web, unified paths like `/assets/images/` are commonly used. At build time, images need to be copied to the correct location and paths adjusted.\n    \n3. **Mermaid Diagram Support**  \n    This post uses mermaid.js for diagrams. I made custom components to support this, but for some reason, they didn’t render properly. So I switched to generating SVG files during preprocessing.\n    \n4. **Multilingual Support and AI Translation**  \n    I wanted the blog in Korean, English, and Japanese. Writing in all three languages every time was difficult, and my language skills limited, so I introduced AI translation. However, markdown syntax sometimes broke or got distorted during translation, requiring multiple prompt revisions.\n\n## Future Plans\n\nCurrently, I manage publishing status with the `published` metadata, but I plan to build a scheduled publishing system that “quietly posts on a set date.”\n\nAlso, I’m considering automatic cross-posting to platforms like Velog or Medium after a certain time, or posting summaries and links to social media like Twitter (X) and LinkedIn upon publishing, though when these will be implemented remains uncertain.\n\n> 💡 **If you want to know more**  \n> \n> All code except the private Vault repository is already available on the [GitHub repository](https://github.com/ironpark/ironpark.github.io). If you’re curious about the preprocessor implementation, check the `auto-sync` branch."}