{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"53625532a96c53b56eb2fd6f7cbb09fea66e4f828365acac42599c3916f7b270","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Plausible Plan","description":"A fully automated system that automatically publishes your writing to the website just by writing and saving in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"똑똑한 블로그 만들기","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [my last post](https://ironpark.github.io/posts/my-ideal-dev-blog/), I talked about why I started this blog and how I chose the technologies. This time, I want to discuss why publishing even a single post on this blog turned out to be so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I’ve experienced running a static blog based on GitHub Pages is **the publishing process itself**.\n\nSince there’s no separate database or server environment, there’s no management page or dedicated editor. As a result, the basic writing flow—drafting → saving → editing → publishing—is not smooth. On top of that, having blog posts and frontend code mixed together in one repository is almost a disaster for someone like me who easily gets sidetracked. So, **separation of concerns** became absolutely necessary.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**My plan was this:**\n1. Write posts in Obsidian\n2. Use a Git plugin to automatically sync to my personal repository\n3. Use GitHub Actions to automatically deploy posts to the blog repository\n\nI was confident this would be a perfect system allowing me to write and publish posts instantly from anywhere—smartphone, tablet, or desktop. I could focus solely on writing in Obsidian, and the rest would be handled automatically by the magic of GitHub Actions... such a beautiful plan.\n\nAlthough it worked perfectly in my head, in reality, there were more hidden pitfalls than I expected.\n\n> Everyone has a plausible plan — until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as 👨‍💻 Author\nparticipant Obsidian as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault Repository\nparticipant BlogRepo as 📁 Blog Repository\nparticipant Pages as 🌐 GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run blog post filtering commit action\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: 💥 Attempt commit push (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: ❌ REJECTED! remote changes exist <br/> Pull required before commit → possible conflict (mix of auto and manual commits)\nend\n```\n\nThe biggest concern was **the entanglement of automatic commits and manual commits within the same repository**.  \nWhat happens if GitHub Actions automatically commits and deploys posts while I’m editing CSS or layout locally?\n\nMost likely, when I try to push, the remote repository will already have commits generated by automation. In that case, `git push` will be rejected, and I’ll have to go through the tedious process of resolving conflicts by running `git reset HEAD^ & git pull`.\n\nIn other words, the automation designed to help me publish posts could easily turn me into a **full-time conflict resolution officer**.\n\n### Second Plan\nThe root cause of the problem was that the automation process commits blog posts directly to the main branch.\n\nSo, what if **posts were fetched dynamically at build time?**\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as 👨‍💻 Author\nparticipant Obsidian as 🪨 Obsidian\nparticipant VaultRepo as 📁 Vault Repository\nparticipant BlogRepo as 📁 Blog Repository\nparticipant Pages as 🌐 GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save posts\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Build process starts\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocess & build site\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\nThis way, **the post repository and the blog code repository are completely separated**. Each commits independently in their own domain, only meeting at build time. Conflicts? They simply can’t happen in this structure.\n\nBut this structure had a fatal flaw: **a public repository had to fetch data from a private repository**. This is a reverse access pattern that goes against common security principles.\n\nMy Obsidian Vault isn’t just a blog repository. It’s my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. The idea of a public blog accessing this personal repository was unsettling.\n\nI considered cloning the private repo using a Personal Access Token, but the risks were too high:\n\n- Sensitive info might be exposed in the public repository’s Actions logs\n- Security risk if the token is stolen, exposing the entire Vault\n- Risk of accidentally including private files in the build process\n\nMost of all, I didn’t trust myself enough to proceed with this plan, so it was scrapped.\n\n### The Final?\n\n![[gendo-Ikari.jpg]]\n> Post publishing system ~~humanity’s~~ final improvement plan\n\nSo I changed my approach. What if I committed automatically to the blog repository as originally planned, but used a separate branch?\n\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"GitHub Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Edit blog design\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"GitHub Pages\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\n\nIn this structure:\n- GitHub Actions in the Vault repo processes posts and pushes to the blog repo’s `auto-sync` branch\n- The blog’s build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code changes are committed directly to the `master` branch as usual\n\nThis setup completely eliminates the possibility of conflicts while securely connecting the two repositories.\n\n### Challenges Encountered\n1. Obsidian Syntax  \nObsidian uses its own markdown extensions. Image embeds like `![[image.png]]` or wiki links like `[[another note]]` don’t render properly in standard markdown preprocessors. A conversion preprocessing step was essential.\n\n2. Image Paths and Asset Management  \nImages in the Obsidian Vault are usually stored in the same folder as notes, but on the web, it’s common to use a unified path like `/assets/images/`. Images had to be copied to the correct location and paths adjusted during the build.\n\n3. Multilingual Support and AI Translation  \nI wanted the blog to be available in Korean, English, and Japanese. Writing posts in three languages every time was impossible, and my foreign language skills are limited, so I introduced AI translation. However, careful handling was required to avoid translating technical terms or code blocks.\n\n---\n\n> 💡 **Curious about this automation system?**\n> \n> The full code is available on the [GitHub repository](https://github.com/ironpark/ironpark.github.io).  \n> Especially check out the action files in the `.github/workflows/` folder for detailed implementation.  \n>\n> If you want to build a similar system, feel free to ask questions anytime. Let’s create a better writing environment together."}