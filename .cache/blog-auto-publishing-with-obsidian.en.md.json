{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"bded00ca93505508f784508c22f61332f61d942b2c8ae2741d57a3bf9a0bf581","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Plausible Plan","description":"A fully automated system that automatically publishes your writing to the website just by writing and saving in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"ë˜‘ë˜‘í•œ ë¸”ë¡œê·¸ ë§Œë“¤ê¸°","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [[ë‚˜ë§Œì˜ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ë‹¤|My Own Blog Creation]], I talked about the reasons for creating the blog and the process of choosing the technology. This time, I want to discuss why publishing a single post on the blog I made is so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages is **the publishing process itself**.\n\nSince there is no separate database or server environment, there is no management page or dedicated editor. As a result, the basic writing flow of draft â†’ save â†’ edit â†’ publish is not smooth. Moreover, having the posts and frontend code mixed in one repository is almost a disaster for me, who easily gets sidetracked. So, **separation of concerns** was desperately needed.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**My plan was this:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to my personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident that this would be a perfect system allowing me to write and deploy posts immediately from smartphone, tablet, or desktop. I could focus solely on writing in Obsidian, and the rest would be handled automatically by the magic of GitHub Actions... such a beautiful plan.\n\nThe plan worked perfectly in my head, but in reality, many unexpected pitfalls were lurking.\n\n> Everyone has a plausible plan â€” until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run commit action to filter blog posts\nVaultRepo ->> BlogRepo: Commit blog posts\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: ğŸ’¥ Attempt to push commit (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: âŒ REJECTED! remote changes exist <br/> Pull required before commit â†’ possible conflict (mix of automatic and manual commits)\nend\n```\n\nThe biggest concern was the **situation where automatic commits and manual commits get tangled in one repository**.  \nWhat if GitHub Actions automatically commits and deploys posts while Iâ€™m editing CSS or layout locally?\n\nMost likely, at the moment I try to push, the remote repository will already have commits created by automation. In that case, `git push` will be rejected, and Iâ€™ll have to go through the tedious process of resolving conflicts by running `git reset HEAD^ & git pull`.\n\nIn other words, the automation I made to publish posts could easily turn me into a **full-time conflict resolution officer**.\n\n### Second Plan\nThe root cause of the problem was that the automation process directly commits blog posts to the main branch.\n\nSo, what if **posts are dynamically fetched at build time?**\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save posts\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Start build process\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocess & build site\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\nThis way, **the post repository and the blog code repository are completely separated**. Each commits independently in their own domain and only meet at build time. Conflicts? Such a thing cannot happen in this structure.\n\nHowever, this structure had a fatal flaw. **The public repository would have to fetch data from the private repository.** This is a reverse access that violates general security principles.\n\nMy Obsidian Vault is not just a simple blog repository. Itâ€™s my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. The idea of a public blog accessing such a personal repository was unsettling.\n\nI also considered cloning the private repository using a Personal Access Token, but there were too many risks:\n\n- Sensitive information could be exposed in the Actions logs of the public repository\n- If the token is stolen, the entire Vault would be exposed to security risks\n- Risk of accidentally including private files in the build process\n\nAbove all, because I donâ€™t trust myself, this plan was discarded.\n\n### The Final?\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> The final version of the post publishing system ~~humanity~~ improvement plan\n\nSo I changed my approach. What if I commit automatically to the blog repository as originally planned, but use a separate branch?\n\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"Github Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Edit blog design\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"Github Page\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\n\nIn this structure:\n- GitHub Actions in the Vault pushes processed posts to the blog repositoryâ€™s `auto-sync` branch\n- The blogâ€™s build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code changes are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely connecting the two repositories without security issues.\n\n### Challenges Encountered\n1. Obsidian Syntax  \nObsidian uses its own markdown extension syntax. Image embeds like `![[image.png]]` or wikilinks like `[[Other Note]]` donâ€™t render as-is in standard markdown preprocessors. A conversion preprocessing step was essential.\n\n2. Image Paths and Asset Management  \nImages in the Obsidian Vault are usually stored in the same folder as the notes, but on the web, itâ€™s common to use a unified path like `/assets/images/`. At build time, images had to be copied to the correct location and paths adjusted.\n\n3. Multilingual Support and AI Translation  \nI wanted the blog to be available in Korean, English, and Japanese. Writing posts in all three languages every time was impossible, and my foreign language skills are limited, so I introduced AI translation. However, careful handling was needed to avoid translating technical terms or code blocks.\n\n---\n\n> ğŸ’¡ **Curious about this automation system?**\n> \n> The full code is available in the [GitHub repository](https://github.com/ironpark/ironpark.github.io).  \n> Especially check the action files in the `.github/workflows/` folder for detailed implementation.  \n>\n> If you want to build a similar system, feel free to ask questions anytime. Letâ€™s create a better writing environment together."}