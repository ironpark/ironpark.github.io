{"metadataHash":"c6528956b8862e867d747f70dc2fc3666a2e8f5440363a1d274a79aa0a621d97","contentHash":"daddefcaafab78bcdaad3b49dc2d38fa6587f1e778cf0d8b7a8383bfb8eb40eb","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":true,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Pretty Good Plan","description":"A fully automated system that publishes your writings to the website automatically once you write and save in Obsidian. An environment built with GitHub Actions and Git synchronization, allowing you to focus solely on writing.","series":"ë˜‘ë˜‘í•œ ë¸”ë¡œê·¸ ë§Œë“¤ê¸°","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn [[ë‚˜ë§Œì˜ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ë‹¤|Last Post]], I talked about why I decided to create a blog and how I chose the technology stack. This time, I want to discuss why publishing even a single post on that blog feels so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages is **the publishing process itself**.\n\nSince thereâ€™s no separate database or server environment, thereâ€™s no management page or dedicated editor. As a result, the basic writing flowâ€”drafting â†’ saving â†’ editing â†’ publishingâ€”is not smooth. On top of that, having blog posts and frontend code mixed in one repository is nearly a disaster for someone like me who easily gets sidetracked. So, **separation of concerns** became absolutely necessary.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**The original plan was like this:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to the personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident this would be a perfect system where I could write and instantly publish from my smartphone, tablet, or desktop. I would focus solely on writing in Obsidian, and the rest would be magically handled by GitHub Actions automationâ€¦ such a beautiful plan.\n\nAlthough this plan ran perfectly in my head, in reality, there were more hidden pitfalls than I expected.\n\n> Everyone has a plausible plan â€” until they get punched in the face.\n\n## Exploring Solutions\n\n### First Plan\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run blog post filtering commit action\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: ğŸ’¥ Attempt to push commit (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: âŒ REJECTED! remote changes exist <br/> Need to pull before commit â†’ possible conflict (mix of auto and manual commits)\nend\n```\n\nThe biggest concern was the **entanglement of automatic commits and manual commits in the same repository**.  \nWhat happens if GitHub Actions automatically commits and deploys posts while Iâ€™m editing CSS or layout locally?\n\nMost likely, at the moment I try to push, the remote repository already contains commits created by automation. In that case, `git push` will be rejected, and Iâ€™ll have to go through the tedious process of resolving conflicts by running `git reset HEAD^ & git pull` again.\n\nBecause of automation meant to publish posts, I almost became a **full-time conflict manager**.\n\n### Second Plan\n\nThe root cause was that the automation process commits blog posts directly to the main branch.\n\nSo, what if **posts were dynamically fetched at build time?**\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save posts\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Build process starts\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocessing & site build\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\nThis way, **the post repository and blog code repository are completely separated**. Each can commit independently in their own domain and only meet at build time. Conflicts? Such things simply cannot occur in this structure.\n\nHowever, this structure had a fatal flaw: **a public repository had to fetch data from a private repository**. This is a reverse access that violates common security principles.\n\nMy Obsidian Vault is not just a simple blog repository. Itâ€™s my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. The idea of a public blog accessing this personal repository was unsettling.\n\n- Sensitive information might be exposed in the public repositoryâ€™s Actions logs\n- If the token is stolen, the entire Vault could be compromised\n- Risk of accidentally including private files in the build process\n\nAbove all, because I donâ€™t trust myself, this plan was discarded.\n\n### Final Plan  \n~~Revision-v3-v3final-last-reallyfinal.doc~~\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> Final version of the post publishing system ~~humanity~~ improvement plan\n\nAfter much thinking, I found my own answer. What if I commit automatically to the blog repository as originally planned, but use a separate branch?\n\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"GitHub Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Blog design edits\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"GitHub Pages\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\n\nIn this structure:\n- GitHub Actions in the Vault processes posts and pushes them to the blog repositoryâ€™s `auto-sync` branch\n- The blogâ€™s build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code edits are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely linking the two repositories.\n\n## Actual Implementation\n\nDevelopers speak with code, right? Below is the GitHub Actions file that realizes the above plan.\n\n**Obsidian Vault (private repository)**\n\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # Run only when specific files change to avoid unnecessary workflow reruns\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      # Checkout brain repository (current repository)\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      # Checkout auto-sync branch of ironpark.github.io\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n      # Install pnpm & cache settings for auto-sync branch of ironpark.github.io\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n      # Copy all assets and posts from brain to contents (auto-sync branch)\n      - name: Sync Contents\n        run: |\n          rm -rf contents/{posts,assets,output}\n          mkdir -p contents/{posts,assets}\n          cp -r brain/2.Areas/Blog/*.md contents/posts/\n          cp -r brain/Z.Assets/* contents/assets/\n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # Check for changes in contents and push if there are any changes\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n          fi\n      # Push Contents if there are any changes\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from $(date +'%Y-%m-%d')\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n\n**Blog (frontend) [repository](https://github.com/ironpark/ironpark.github.io)**\n\n```yaml\nname: Build and Deploy to Pages\n\non:\n  push:\n    branches: [\"master\"]\n  workflow_dispatch:\n  repository_dispatch:\n    types: [ post-sync ]\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n# Allow one concurrent deployment\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\njobs:\n  build:\n    env:\n      GITHUB_TOKEN: ${{ github.token }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/checkout@v4\n        with:\n          path: ./sync\n          ref: auto-sync\n      - uses: actions/configure-pages@v5\n        id: pages\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'pnpm'\n      - name: Copy posts\n        run: |\n          rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n          rm -rf ./static/posts ; mkdir -p ./static/posts\n          cp -r ./sync/output/posts/*.md ./src/content/blog\n          cp -r ./sync/output/static/posts/* ./static/posts\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n      - name: Build\n        run: pnpm run build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./build\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n      - uses: actions/deploy-pages@v4\n        id: deployment\n```\n\n### A Closer Look\n\nNo matter how much developers speak with code, itâ€™s a bit cold to just drop code and disappear. For anyone who might want to try this, let me dissect how these two GitHub Actions workflows work together. Although it looks complicated at first glance, each has a clear role, so I believe you can understand it step by step.\n\n#### Vault Repository Workflow Analysis\n\nFirst, letâ€™s look at the `Contents Sync` workflow in the Obsidian Vault repository.\n\n**Trigger Conditions**\n```yaml\non:\n  workflow_dispatch:            # Can be run manually\n  push:\n    paths:\n      - \"2.Areas/Blog/*.md\"     # Only when blog posts change\n      - \".github/workflows/**\"  # Or when workflow files change\n    branches:\n      - main\n```\n\nUsing the `paths` filter, it only runs **when blog-related files change**. This prevents unnecessary builds and saves GitHub Actions free tier minutes (2,000 minutes per month). Of course, properly setting `.gitignore` to avoid committing unnecessary files is also essential.\n\n**Checking Out Two Repositories Simultaneously**\n```yaml\n- name: Checkout brain repository\n  uses: actions/checkout@v4\n  with:\n    path: brain     # Check out current repository (vault) into brain folder\n    \n- name: Checkout contents repository\n  uses: actions/checkout@v4\n  with:\n    repository: ironpark/ironpark.github.io # From the blogâ€™s GitHub repository\n    ref: auto-sync  # The auto-sync branch\n    path: contents  # Check out into contents folder\n    token: ${{ secrets.GH_TOKEN }}  # Token for external repo access\n```\n\nWithin one workflow, **two repositories are checked out into different paths**. This allows simple `cp` commands to move files easily without complex scripts. The token is set here for committing and pushing later.\n\n**Post Preprocessing**\n```yaml\n- name: Sync Contents  # Remove old files, create directories, copy markdown posts & images\n  run: |\n    rm -rf contents/{posts,assets,output}\n    mkdir -p contents/{posts,assets}\n    cp -r brain/2.Areas/Blog/*.md contents/posts/\n    cp -r brain/Z.Assets/* contents/assets/\n\n- name: Build Contents # Run preprocessing (Obsidian syntax conversion, translation, etc.)\n  working-directory: contents\n  run: |\n    pnpm build\n```\n\nFirst, markdown files and images are copied from the Vault to the blog repositoryâ€™s `auto-sync` branch.  \nThen, `pnpm build` runs the preprocessor.\n\nThis preprocessor performs tasks such as:\n- Converting Obsidianâ€™s `![[image.png]]` syntax to standard markdown\n- AI translation (multilingual support)\n- Other preprocessing tasks...\n\nThis preprocessor plays a key role in building this blog but is too large to cover here.\n\n**Checking for Changes and Conditional Push**\n```yaml\n- name: Check for changes\n  id: check_changes\n  run: |\n    git add .\n    if git diff --staged --quiet; then\n      echo \"changes=false\" >> $GITHUB_OUTPUT\n    else\n      echo \"changes=true\" >> $GITHUB_OUTPUT\n    fi\n\n- name: Push Contents\n  if: steps.check_changes.outputs.changes == 'true'  # Only if there are changes\n```\n\nAfter preprocessing, it commits only if there are actual changes. This prevents unnecessary commits and deployments if nothing has changed.\n\n**Triggering Blog Build**\n```yaml\n- name: Run Publish\n  run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n```\n\nUsing GitHub CLI, it triggers a `repository_dispatch` event on the blog repository. This is the key link connecting the two workflows. The `event_type` acts like a label to distinguish why the trigger happened.\n\n#### Blog Repository Workflow Analysis\n\nNow, letâ€™s look at the `Build and Deploy to Pages` workflow in the blog repository.\n\n**Supporting Various Triggers**\n```yaml\non:\n  push:\n    branches: [\"master\"]  # When code changes\n  workflow_dispatch:      # Manual trigger\n  repository_dispatch:    \n    types: [ post-sync ]  # Event sent from Vault\n```\n\nThere are three triggers declared, and among them, `repository_dispatch` is the crucial link to the Vault repository. The Vault workflow needs this to trigger the blog deployment workflow.\n\n**Merging Two Branches**\n```yaml\n- uses: actions/checkout@v4  # Checkout master branch\n- uses: actions/checkout@v4\n  with:\n    path: ./sync\n    ref: auto-sync  # Checkout auto-sync branch into sync folder\n    \n- name: Copy posts\n  run: |\n    rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n    rm -rf ./static/posts ; mkdir -p ./static/posts\n    cp -r ./sync/output/posts/*.md ./src/content/blog  # Copy preprocessed posts\n    cp -r ./sync/output/static/posts/* ./static/posts  # Static files like images\n```\n\nIt merges the code from the `master` branch and the content from the `auto-sync` branch to build the site. This achieves perfect separation of code and content.\n\n#### Security Considerations\n\nBoth workflows use `${{ secrets.GH_TOKEN }}`. This token is:\n- Granted read/write permissions only on the blog repo\n- A fine-grained PAT with minimal privileges\n\nThis minimizes damage even if the token is leaked.\n\n#### Why So Complicated?\n\nYou might wonder, â€œWhy make publishing a single post so complicated?â€ But thanks to thisâ€¦\n\n1. **Perfect separation of concerns**: Writing and coding donâ€™t interfere with each other  \n2. **Conflict-free collaboration**: Automation and manual work coexist peacefully  \n3. **Extensibility**: Easy to add features like preprocessing, translation, cross-posting  \n4. **Security**: Separation between personal Vault and blog content\n\nUltimately, this seemingly complex system started from the simple desire to **just focus on writing**. Sometimes, you have to take a complicated journey to achieve a simple goal.\n\n## Things Not Covered in This Post\n\nPosts written in Obsidian basically follow markdown format, but applying them directly to the blog was difficult. So I had to create a separate preprocessor, and encountered various issues along the way. I didnâ€™t cover them here, but I plan to write about them separately when I get the chance.\n\n1. **Obsidian Syntax**  \n    Obsidian uses its own markdown extensions. For example, image embeds like `![[image.png]]` or wikilinks like `[[another note]]` donâ€™t render properly in standard markdown renderers. So a preprocessing step to convert these was essential.\n    \n2. **Image Paths and Asset Management**  \n    Obsidian Vault images are usually stored in the same folder as notes, but on the web, unified paths like `/assets/images/` are commonly used. At build time, images need to be copied to the correct location and paths adjusted.\n    \n3. **Mermaid Diagram Support**  \n    This post used mermaid.js for diagrams. But to render them properly in a static site build, a separate process supporting dynamic rendering was needed.\n    \n4. **Multilingual Support and AI Translation**  \n    I wanted to offer the blog in Korean, English, and Japanese. Writing in all three languages manually is difficult, and my foreign language skills are limited, so I introduced AI translation. However, markdown syntax sometimes broke or got altered during translation, requiring multiple prompt adjustments.\n\n> ğŸ’¡ **Curious about the preprocessor?**\n> \n> The entire code except the private repository is already available on the [GitHub repository](https://github.com/ironpark/ironpark.github.io). If youâ€™re especially curious about the preprocessor implementation, check out the `auto-sync` branch.\n\n## Plans for the Future\n\nCurrently, I manage publication status with the `published` metadata, but I plan to build a scheduled publishing system to â€œquietly post on a set date.â€\n\nAdditionally, Iâ€™m considering features like automatically cross-posting to platforms like Velog or Medium after a certain time, or posting summaries and links to social media like Twitter (X) and LinkedIn upon publishing. However, when or if these will be implemented remains uncertain."}