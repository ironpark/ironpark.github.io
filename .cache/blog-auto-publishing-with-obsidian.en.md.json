{"metadataHash":"bdd277aadc30a7566f6145a0b07405b25ca2faaaeaee57b9eb312c9556c5d3ea","contentHash":"c53bbab98bb97c36d8b975484b48a4d7ed707ccdb076c6a01da40eb528471b75","metadata":{"created":"2025-07-28T14:30:00.000Z","updated":"2025-08-08T14:50:00.000Z","published":false,"slug":"blog-auto-publishing-with-obsidian","title":"Automatic Blog Publishing (feat. Obsidian)","subTitle":"Everyone Has a Plausible Plan","description":"A fully automated system that publishes your writing to the website automatically whenever you write and save in Obsidian. Creating an environment focused solely on writing by integrating GitHub Actions and Git synchronization.","series":"ë˜‘ë˜‘í•œ ë¸”ë¡œê·¸ ë§Œë“¤ê¸°","categories":["Dev"],"tags":["obsidian","github-actions","automation","workflow","markdown"],"lang":"en","thumbnail":null,"originalLang":"ko"},"content":"## Why Is Publishing a Single Post So Complicated?\n\nIn the [[ë‚˜ë§Œì˜ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ë‹¤|previous post]], I talked about why I created my blog and how I chose the technologies. This time, I want to discuss why publishing even a single post on that blog is so complicated, and how I tried to untangle that process.\n\nThe biggest inconvenience I felt while running a static blog based on GitHub Pages was **the publishing process itself**.\n\nSince thereâ€™s no separate database or server environment, thereâ€™s no management page or dedicated editor. As a result, the basic writing flowâ€”drafting â†’ saving â†’ editing â†’ publishingâ€”is not smooth. On top of that, having blog posts and frontend code mixed in one repository is practically a disaster for someone like me who easily gets sidetracked. So, **separation of concerns** was desperately needed.\n\n### Everyone Has a Plausible Plan\n![[get-punched-in-the-face.jpg]]\n\n**The original plan was this:**\n1. Write posts in Obsidian\n2. A Git plugin automatically syncs to a personal repository\n3. GitHub Actions automatically deploy posts to the blog repository\n\nI was confident this would be a perfect system where I could write and deploy posts instantly from my smartphone, tablet, or desktop. Just focus on writing in Obsidian, and let the automation magic of GitHub Actions handle the rest... It was such a beautiful plan...\n\nAlthough it worked perfectly in my head, in reality, there were many hidden pitfalls.\n\n> Everyone has a plausible plan  ~~until they get punched in the face~~\n\n## Exploring Solutions\n\n### First Plan\n\n\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Run blog post filtering commit action\nVaultRepo ->> BlogRepo: Commit blog post\nNote over BlogRepo: Build & deploy\nBlogRepo ->> Pages: Deploy static site\nNote over Developer: Edit CSS locally, commit\nDeveloper ->> BlogRepo: ğŸ’¥ Attempt to push commit (commit B)\nrect rgb(250,200,200)\nBlogRepo -->> Developer: âŒ REJECTED! remote changes exist <br/> Need to pull before commit â†’ possible conflicts (mix of auto and manual commits)\nend\n```\n\nThe biggest concern was **the entanglement of automatic commits and manual commits in the same repository**.  \nWhat happens if GitHub Actions automatically commits and deploys posts while Iâ€™m editing CSS or layout locally?\n\nMost likely, the moment I try to push, the remote repository will already have commits created by automation. In that case, `git push` will be rejected, and Iâ€™ll have to go through the tedious process of resolving conflicts by running `git reset HEAD^ & git pull`.\n\nI almost became a **full-time conflict manager** because of the automation I built to publish posts.\n\n### Second Plan\nThe root cause was that the automation process committed blog posts directly to the main branch.\n\nSo, what if **posts were fetched dynamically at build time?**\n```mermaid\nsequenceDiagram\nautonumber\nparticipant Developer as ğŸ‘¨â€ğŸ’» Author\nparticipant Obsidian as ğŸª¨ Obsidian\nparticipant VaultRepo as ğŸ“ Vault Repository\nparticipant BlogRepo as ğŸ“ Blog Repository\nparticipant Pages as ğŸŒ GitHub Pages\n\nDeveloper ->> Obsidian: Write blog post\nObsidian ->> VaultRepo: Sync commit\nNote over VaultRepo: Save posts\n\nDeveloper ->> BlogRepo: Edit CSS/layout\nBlogRepo ->> BlogRepo: Trigger build\n\nrect rgb(200,250,200)\nNote over BlogRepo: Start build process\nBlogRepo ->> VaultRepo: Fetch post data (checkout)\nVaultRepo -->> BlogRepo: Markdown files\nNote over BlogRepo: Preprocessing & site build\nend\n\nBlogRepo ->> Pages: Deploy static site\n```\n\n\nThis way, **the post repository and blog code repository are completely separated**. Each commits independently in their own domain and only meet at build time. Conflicts? Such a thing canâ€™t happen in this structure.\n\nHowever, this structure had a fatal flaw. **The public repository had to fetch data from the private repository.** This was a reverse access that violated common security principles.\n\nMy Obsidian Vault is not just a simple blog repository. Itâ€™s my personal digital brain containing private diaries, work notes, project ideas, and sometimes sensitive information. The idea of a public blog accessing this personal repository was unsettling.\n\n- Risk of exposing sensitive information in the public repositoryâ€™s Actions logs\n- Security risk of the entire Vault being compromised if the token is stolen\n- Risk of accidentally including private files during the build process\n\nMost of all, because I donâ€™t trust myself, this plan was scrapped.\n\n### Final Plan\n~~Revision-v3-v3final-last-truefinal.doc~~\n\n![[Neon-Genesis-Evangeliongendo-Ikari-Gendo.jpg]]\n> Final version of the post publishing system ~~humanity~~ enhancement plan\n\nAfter thinking hard, I found my own solution. What if I commit automatically to the blog repository as originally planned, but use a separate branch?\n\n```mermaid\nflowchart TB\n subgraph subGraph0[\"Private Vault Repo\"]\n direction TB\n A[\"Obsidian Notes\"]\n B[\"GitHub Actions\"]\n C[\"Preprocessing & Translation\"]\n end\n subgraph subGraph1[\"Public Blog Repo\"]\n direction TB\n D[\"auto-sync branch\"]\n E[\"master branch\"]\n F[\"GitHub Actions\"]\n end\n subgraph subGraph3[\"User\"]\n direction TB\n H[\"Blog design edits\"]\n I[\"Commit\"]\n J[\"Push\"]\n end\n A --- B\n B --> C\n C --commit--> D\n D -. checkout .-> B\n D -. checkout .-> F\n E -. checkout .-> F\n F --> G[\"GitHub Pages\"]\n H --- I --> J --> E\n style A fill:#f9f\n style D fill:#9f9\n style F fill:#bbf\n```\nIn this structure:\n- GitHub Actions in the Vault process posts and push to the blog repositoryâ€™s `auto-sync` branch\n- The blogâ€™s build process checks out and merges both `master` and `auto-sync` branches before building\n- Design or code edits are committed directly to the `master` branch as usual\n\nThis structure completely eliminates the possibility of conflicts while securely linking the two repositories.\n\n## Actual Implementation\n\nIsnâ€™t code better than words? Below is the GitHub Actions file that realizes the above plan.\n\n**Obsidian Vault (Private Repository)**\n\n```yaml\nname: Contents Sync\n# This workflow syncs contents between the main branch and the blog branch.\non:\n  workflow_dispatch:\n  push:\n    # Run only when specific files change to avoid unnecessary workflow re-runs\n    paths:\n      - \"2.Areas/Blog/*.md\"\n      - \".github/workflows/**\"\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      # Checkout brain repository (current repository)\n      - name: Checkout brain repository\n        uses: actions/checkout@v4\n        with:\n          path: brain\n      # Checkout auto-sync branch of ironpark.github.io\n      - name: Checkout contents repository\n        uses: actions/checkout@v4\n        with:\n          repository: ironpark/ironpark.github.io\n          ref: auto-sync\n          path: contents\n          token: ${{ secrets.GH_TOKEN }}\n      # Install pnpm & cache settings for auto-sync branch of ironpark.github.io\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: \"pnpm\"\n          cache-dependency-path: contents/pnpm-lock.yaml\n      - name: Install dependencies\n        working-directory: contents\n        run: pnpm install --frozen-lockfile\n      # Copy all assets and posts from brain to contents (auto-sync branch)\n      - name: Sync Contents\n        run: |\n          rm -rf contents/{posts,assets,output}\n          mkdir -p contents/{posts,assets}\n          cp -r brain/2.Areas/Blog/*.md contents/posts/\n          cp -r brain/Z.Assets/* contents/assets/\n      - name: Build Contents\n        working-directory: contents\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          pnpm build\n      # Check for changes in contents and push if there are any changes\n      - name: Check for changes\n        id: check_changes\n        working-directory: contents\n        run: |\n          git add .\n          if git diff --staged --quiet; then\n            echo \"changes=false\" >> $GITHUB_OUTPUT\n          else\n            echo \"changes=true\" >> $GITHUB_OUTPUT\n          fi\n      # Push Contents if there are any changes\n      - name: Push Contents\n        if: steps.check_changes.outputs.changes == 'true'\n        working-directory: contents\n        run: |\n          git config --global user.email \"auto-sync-action@github.com\"\n          git config --global user.name \"auto-sync-action\"\n          git commit -m \"sync contents from $(date +'%Y-%m-%d')\"\n          git push origin auto-sync\n      - name: Run Publish\n        run: gh api /repos/ironpark/ironpark.github.io/dispatches -f event_type='post-sync'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n```\n\n**Blog (Frontend) [Repository](https://github.com/ironpark/ironpark.github.io)**\n\n```yaml\nname: Build and Deploy to Pages\n\non:\n  push:\n    branches: [\"master\"]\n  workflow_dispatch:\n  repository_dispatch:\n    types: [ post-sync ]\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n# Allow one concurrent deployment\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\njobs:\n  build:\n    env:\n      GITHUB_TOKEN: ${{ github.token }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/checkout@v4\n        with:\n          path: ./sync\n          ref: auto-sync\n      - uses: actions/configure-pages@v5\n        id: pages\n      - uses: pnpm/action-setup@v4\n        name: Install pnpm\n        with:\n          version: 10.12.4\n          run_install: false\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'pnpm'\n      - name: Copy posts\n        run: |\n          rm -rf ./src/content/blog ; mkdir -p ./src/content/blog\n          rm -rf ./static/posts ; mkdir -p ./static/posts\n          cp -r ./sync/output/posts/*.md ./src/content/blog\n          cp -r ./sync/output/static/posts/* ./static/posts\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n      - name: Build\n        run: pnpm run build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./build\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n      - uses: actions/deploy-pages@v4\n        id: deployment\n```\n\n### Deep Dive\n\n## Things Not Covered in This Post\n\nAlthough posts written in Obsidian basically follow Markdown format, applying them directly to the blog was difficult. So I had to create a separate preprocessor, and encountered various issues in the process. I didnâ€™t cover these in this post but plan to organize and share them separately when I have time.\n\n1. **Obsidian Syntax**  \n    Obsidian uses its own Markdown extension syntax. For example, image embeds like `![[image.png]]` or wikilinks like `[[another note]]` donâ€™t render properly in a standard Markdown renderer. So a preprocessing step to convert these was essential.\n    \n2. **Image Paths and Asset Management**  \n    Image files in the Obsidian Vault are usually stored in the same folder as the notes, but on the web, unified paths like `/assets/images/` are generally used. At build time, images needed to be copied to the correct location and paths adjusted accordingly.\n    \n3. **Mermaid Diagram Support**  \n    This post used mermaid.js for diagrams. However, to render these properly in a static site build, a separate handling method supporting dynamic rendering was necessary.\n    \n4. **Multilingual Support and AI Translation**  \n    I wanted to offer the blog in Korean, English, and Japanese. Writing in all three languages manually was difficult, and my foreign language skills were limited, so I introduced AI translation. However, the Markdown syntax sometimes got distorted or broken during translation, so I had to revise prompts several times.\n\n## Future Plans\n\nCurrently, I manage publication status with the `published` metadata, but I plan to create a scheduled publishing system that â€œquietly posts on a set date.â€\n\nBesides that, Iâ€™m considering automatic cross-posting to other platforms like Velog or Medium after a certain time, or posting summaries and links to SNS like Twitter (X) and LinkedIn simultaneously upon publishing. But when these will be implemented is still unknown...\n\n> Itâ€™s still just an idea, but my goal is to squeeze GitHub Actions to the limit of the free tier. (At this point, it feels less like the machine is working hard and more like Iâ€™m being overworked.)\n\n---\n\n> ğŸ’¡ **Curious about this automation system?**\n> \n> You can check out the entire code on the [GitHub repository](https://github.com/ironpark/ironpark.github.io).  \n> Especially, looking into the action files in the `.github/workflows/` folder reveals detailed implementation.\n>\n> If you want to build a similar system, feel free to ask questions anytime. Letâ€™s create a better writing environment together."}