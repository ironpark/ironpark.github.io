{"metadataHash":"015f39fb0c35aa1b45d30d6fd3ee7ee03f9dbddfa72b8bfe82b5bbaa098efe09","contentHash":"99ce5e554e5c7eb4f6ddd9ceab46867f398c4af0cc1f82c5a7b78bbb6c8ec020","metadata":{"created":"2025-08-25T11:30:12.000Z","updated":"2025-09-03T13:25:35.000Z","published":"2025-09-03T12:37:29.000Z","slug":"why-i-became-a-go-developer","title":"What Makes Me Fall in Love with Go","subTitle":"An Accidental Go Developer","description":"I've summarized the reasons I love the Go language, along with some code snippets. Who knows, you might just fall for Go too!","series":"","categories":["Thoughts"],"tags":["golang"],"lang":"en","thumbnail":"","originalLang":"ko"},"content":"# Somehow Go\n![[i-like-go-title.jpg]]\n\nWhen you work as a developer for a long time, you naturally end up using various programming languages, and you tend to develop favorites among languages or frameworks. For me, that was Go. Today, I’ve summarized the reasons why I’ve come to embrace the Go language, sprinkled with a bit? of code. Who knows, maybe you’ll end up falling for Go too?\n\n> **Disclaimer**: This article is purely based on my personal experience and preferences. Go is not the best choice in every situation, and I acknowledge that the features I like might be drawbacks for other developers.\n\n## The Power of Simplicity\nThe first charm of Go I want to introduce is its simplicity. The language syntax is minimal and intuitive, so if you have experience with statically typed languages, you’ll pick it up quickly. There are basically 25 reserved keywords. Considering that other languages (C, C++, Java, etc.) usually have anywhere from 35 to over 70 reserved keywords, this is quite few.\n\n- **Declarations:** `const`, `func`, `import`, `package`, `type`, `var`\n- **Composite types:** `chan`, `interface`, `map`, `struct`\n- **Control flow:** `break`, `case`, `continue`, `default`, `defer`, `else`, `fallthrough`, `for`, `go`, `goto`, `if`, `range`, `return`, `select`, `switch`\n\nBeyond that, Go’s design philosophy emphasizes simplicity and clarity over adding many advanced features, as seen in its type inference system, error handling approach, and polymorphism without inheritance.\n\n```go\n// HELLO WORLD! A very simple Go program example\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}\n```\n\n```go\n// Traditional for loop\nfor i := 0; i < 10; i++ { }\n\n// Used like a while loop\nfor condition { }\n\n// Infinite loop\nfor { }\n```\n\n```go\n// try-catch means service termination!\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n    return err\n}\n```\n\nThis simplicity makes code easier to understand, helps write more predictable code, and makes it relatively easy to read and analyze others’ source code. ~~It doesn’t feel unfamiliar even when you see it for the first time~~\n\n## Compatibility Promise\n\n![[thats-a-promise.gif]]\n> Backward compatibility guaranteed, because that’s the promise.\n\nThe [Compatibility Promise](https://go.dev/doc/go1compat) starting from Go 1.0 is another major advantage of Go. This promise ensures that code written for Go 1.x will continue to work in future versions.\n\nIn real development, you often have to use old libraries that are no longer updated. In Go, even these libraries work without issues on the latest compiler. This means projects written years ago can be built with the latest compiler without any modifications, automatically benefiting from performance improvements and optimizations. There’s no such thing as a free lunch, but a little exception like this is nice, isn’t it?\n\nHowever, subtle behavior changes may occur due to bug fixes or security patches in the standard library, so it’s always good to check the release notes when upgrading.\n\n## Fast Build Speed\n\nWhen I first encountered Go, since I mainly used C/C++ and Java, I could really feel the difference in build speed. While it’s no match for interpreted languages that run immediately, among compiled languages, Go boasts astonishingly fast build times. Thanks to this, you can modify code and run it right away, greatly improving development productivity.\n\n## Static Linking, Single Binary\n\nProvided you don’t add dynamic linking using CGO, Go by default produces a single binary that includes all dependencies. This makes deployment extremely simple. Even more impressively, with the `embed` package, you can embed not only source code but also various static files into the binary.\n\n```go\npackage main\n\nimport (\n    _ \"embed\"\n    \"fmt\"\n)\n\n// Embed a text file into the binary\n//go:embed hello.txt\nvar helloText string\n\n// Embed a binary file into the binary\n//go:embed logo.png\nvar logoData []byte\n\nfunc main() {\n    fmt.Println(helloText)\n    fmt.Printf(\"Logo size: %d bytes\\n\", len(logoData))\n}\n```\n\n## Extensive Standard Library\nGo’s standard library is surprisingly rich. It provides built-in support for network protocols like `net/http`, `net/smtp`, regular expressions, over 20 cryptographic algorithms, JSON, XML, Base64, and various data encodings. It even includes an AST parser capable of analyzing Go source code itself—almost like a comprehensive gift set.\n\nBecause the standard library is continuously maintained and managed by the Go team, you can significantly reduce dependency on third-party libraries, which in turn improves your project’s stability and security.\n\n## Concurrency\n### The Power of Goroutines\nOne core feature you can’t talk about Go without mentioning is\n\n![[go-rou-tine-0.jpg]]\n\n**Go.Rou.Tine**\n\nGoroutines are lightweight threads managed by the Go runtime, with extremely low creation cost compared to OS threads. Their initial stack size is only 2KB, and you can run tens of thousands of goroutines simultaneously without putting much strain on the system (aside from the code running inside the routines).\n\nHonestly, they simplify concurrency and parallelism implementation to a near-magical level. Every time I use other languages, I find myself saying, “Ah, I wish I could use goroutines.”\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc sayHello(name string) {\n    for i := 0; i < 3; i++ {\n        fmt.Printf(\"Hello %s!\\n\", name)\n        time.Sleep(100 * time.Millisecond)\n    }\n}\n\nfunc main() {\n    // Regular function call\n    sayHello(\"World\")\n    \n    // Run as goroutines - just add the go keyword\n    go sayHello(\"Goroutine\")\n    go sayHello(\"Go\")\n    \n    // Wait for goroutines to finish\n    time.Sleep(time.Second)\n}\n```\n\n### Communication via Channels\n\nGo’s concurrency philosophy is based on the principle “Don’t communicate by sharing memory; share memory by communicating.” Channels are the key tool implementing this philosophy, enabling safe communication between goroutines.\n\nChannels can be thought of as typed pipes or thread-safe special queues. One side sends data, and the other receives it—a simple structure that allows elegant implementation of complex concurrency patterns.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Create a channel\n    messages := make(chan string)\n    \n    // Send a message to the channel from a goroutine\n    go func() {\n        time.Sleep(time.Second)\n        messages <- \"Hello from goroutine!\"\n    }()\n    \n    // Receive message in the main goroutine\n    msg := <-messages\n    fmt.Println(msg)\n}\n```\n\n```go\nfunc worker(id int, jobs <-chan string, results chan<- string) {\n    for job := range jobs {\n        fmt.Printf(\"Worker %d processing: %s\\n\", id, job)\n        results <- strings.ToUpper(job)\n    }\n}\n\nfunc main() {\n    // Create buffered channels\n    jobs := make(chan string, 10)\n    results := make(chan string, 10)\n    \n    // Start 5 worker goroutines\n    for i := 1; i <= 5; i++ {\n        go worker(i, jobs, results)\n    }\n    \n    // Send tasks\n    tasks := []string{\"hello\", \"world\", \"golang\", \"concurrency\", \"is\", \"awesome\"}\n    for _, task := range tasks {\n        jobs <- task\n    }\n    // Receive results (as many as tasks)\n    for i := 0; i < len(tasks); i++ {\n        result := <-results\n        fmt.Println(\"Result:\", result)\n    }\n}\n```\n\n### Traditional Synchronization Methods Are Also Supported\n\n> Of all the monsters who fill the nightmares of our folklore, none terrify more than  \nwerewolves, because they transform unexpectedly from the familiar into horrors. For  \nthese, we seek bullets of silver that can magically lay them to rest.  \n> No Silver Bullet - *Frederick P. Brooks, Jr*\n\nAs the old saying [No Silver Bullet](https://worrydream.com/refs/Brooks_1986_-_No_Silver_Bullet.pdf) goes, channels are powerful concurrency tools in Go, but they are not always the best choice. When you simply need to safely update shared variables or protect critical sections, traditional synchronization methods are often more appropriate.\n\nGo fully supports these needs. Low-level control is possible via the `sync` package’s mutexes and the `sync/atomic` package.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar (\n    counter int\n    mu      sync.Mutex\n)\n\nfunc main() {\n    var wg sync.WaitGroup\n    \n    // 1000 goroutines incrementing the counter concurrently\n    for i := 0; i < 1000; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            mu.Lock()\n            counter++\n            mu.Unlock()\n        }()\n    }\n    \n    wg.Wait()\n    fmt.Printf(\"Final counter value: %d\\n\", counter)\n}\n```\n\n### No Function Coloring Problem\n\nMany languages that support asynchronous programming suffer from the [Function Coloring Problem](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/), but Go does not.\n\nOther languages require distinguishing between synchronous and asynchronous functions. JavaScript’s `async/await` and Python’s `async def` are prime examples. Typically, asynchronous functions can only be called within asynchronous contexts, and this requirement spreads like an epidemic throughout the codebase.\n\n```go\n// In Go, there is no sync/async distinction\nfunc fetchData() string {\n    // This function can be called synchronously or asynchronously\n    time.Sleep(100 * time.Millisecond)\n    return \"data\"\n}\n\nfunc main() {\n    // Synchronous call\n    result := fetchData()\n    \n    // Asynchronous call - no change in function signature\n    go fetchData()\n    \n    // Using with channels\n    ch := make(chan string)\n    go func() {\n        ch <- fetchData()\n    }()\n}\n```\n\nBecause goroutines are lightweight threads managed by the language runtime, every function can potentially be concurrent. There’s no need to mark functions as `async` or use special syntax. This greatly reduces code complexity and frees up my limited single-core brain CPU cycles to focus on writing business logic.\n\n## Why Not ... ?\n\n### Rust\nRust is an excellent language in terms of memory safety and performance, but many of the projects I work on inevitably require using C/C++ libraries, and that process was painful. You can try to find well-wrapped libraries, but it’s not uncommon to encounter cases where they don’t provide all features or don’t work properly.\n\nGo’s CGO isn’t perfect either, but it felt more intuitive to use than writing binding code from scratch. If you’re working on a project with little or no C dependency and performance is critical, Rust might be worth considering.\n\n### Zig\nZig is an interesting language with an ambitious goal to replace C. It’s especially excellent in terms of interoperability with C/C++, but I feel there’s still a lack of resources and the language/ecosystem is rapidly evolving. I’m keeping an eye on it with interest.\n\n## In Conclusion\n\nI don’t use Go in every case, but in many situations, I choose Go. No language is perfect, and each has its trade-offs.\n\nFor me, Go strikes a good balance of stability, simplicity, and practicality, feeling like a plain but satisfying meal you never get tired of eating every day. Yes, a language can be a bit boring.\n\n> \"What is your favorite language? And why do you like it?\""}